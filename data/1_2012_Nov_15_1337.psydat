ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V../data\u005c1_2012_Nov_15_1337
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'None'
p11
sS'dataNames'
p12
(lp13
S'key_resp.keys'
p14
aS'key_resp.corr'
p15
aS'key_resp.rt'
p16
asS'extraInfo'
p17
(dp18
S'date'
p19
V2012_Nov_15_1337
p20
sS'expName'
p21
g11
sVsession
p22
V001
p23
sVparticipant
p24
V1
ssS'loopsUnfinished'
p25
(lp26
sS'saveWideText'
p27
I01
sS'thisEntry'
p28
(dp29
sS'version'
p30
S''
sS'_paramNamesSoFar'
p31
(lp32
Vinc_response
p33
aVstim
p34
aVkross
p35
aVpresentation_order
p36
aVzcue
p37
aVcorrect_response
p38
aViSI
p39
aVpros_stim
p40
aVevent_code
p41
aVemoticon_H
p42
aVcor_response
p43
asS'entries'
p44
(lp45
(dp46
g22
g23
sS'trials.thisIndex'
p47
cnumpy.core.multiarray
scalar
p48
(cnumpy
dtype
p49
(S'i4'
I0
I1
tRp50
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp51
sg33
I96
sg15
I0
sg24
V1
sg14
Nsg36
I1
sS'trials.thisRepN'
p52
I0
sg42
VEmoticons_H.bmp
p53
sg21
g11
sS'trials.thisN'
p54
I0
sg38
I66
sg39
F2.688027210884353
sg34
V1_fea_sw_trimF
p55
sS'trials.thisTrialN'
p56
I0
sg40
V1_fea_sw_trimF.wav
p57
sg41
I25
sg37
F0.97211157047895325
sg19
g20
sg43
I2
sg35
Vcross.bmp
p58
sa(dp59
g22
g23
sS'trials.thisIndex'
p60
g48
(g50
S'\x01\x00\x00\x00'
tRp61
sg33
I80
sg15
I0
sg24
V1
sg14
Nsg36
I2
sS'trials.thisRepN'
p62
I0
sg42
g53
sg21
g11
sS'trials.thisN'
p63
I1
sg38
I50
sg39
F3.5404761904761903
sg34
V2_ang_qw_trimF
p64
sS'trials.thisTrialN'
p65
I1
sg40
V2_ang_qw_trimF.wav
p66
sg41
I9
sg37
F-1.4805664680963626
sg19
g20
sg43
I3
sg35
g58
sa(dp67
g22
g23
sS'trials.thisIndex'
p68
g48
(g50
S'\x02\x00\x00\x00'
tRp69
sg33
I97
sg15
I0
sg24
V1
sg14
Nsg36
I3
sS'trials.thisRepN'
p70
I0
sg42
g53
sg21
g11
sS'trials.thisN'
p71
I2
sg38
I67
sg39
F3.0989115646258503
sg34
V4_fea_sw_trimF
p72
sS'trials.thisTrialN'
p73
I2
sg40
V4_fea_sw_trimF.wav
p74
sg41
I26
sg37
F0.98948011330479291
sg19
g20
sg43
I2
sg35
g58
sa(dp75
g14
S'3'
sg36
I4
sg37
F-0.41232228679959398
sg38
I54
sg34
V4_ang_qw_trimF
p76
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p77
g48
(g50
S'\x03\x00\x00\x00'
tRp78
sg33
I84
sg15
I1
sg24
V1
sg16
F1.4806079230898064
sS'trials.thisRepN'
p79
I0
sS'trials.thisN'
p80
I3
sg39
F3.1113832199546403
sg21
g11
sS'trials.thisTrialN'
p81
I3
sg40
V4_ang_qw_trimF.wav
p82
sg41
I13
sa(dp83
g14
S'3'
sg36
I5
sg37
F-0.53706073129766818
sg38
I43
sg34
V4_hap_qs_trimF
p84
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p85
g48
(g50
S'\x04\x00\x00\x00'
tRp86
sg33
I73
sg15
I0
sg24
V1
sg16
F0.36204380592079843
sS'trials.thisRepN'
p87
I0
sS'trials.thisN'
p88
I4
sg39
F3.75081632653061
sg21
g11
sS'trials.thisTrialN'
p89
I4
sg40
V4_hap_qs_trimF.wav
p90
sg41
I3
sa(dp91
g14
S'2'
sg36
I6
sg37
F-1.1424907215263371
sg38
I41
sg34
V4_hap_qw_trimF
p92
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p93
g48
(g50
S'\x05\x00\x00\x00'
tRp94
sg33
I71
sg15
I0
sg24
V1
sg16
F1.5963029172944729
sS'trials.thisRepN'
p95
I0
sS'trials.thisN'
p96
I5
sg39
F3.13696145124716
sg21
g11
sS'trials.thisTrialN'
p97
I5
sg40
V4_hap_qw_trimF.wav
p98
sg41
I1
sa(dp99
g14
S'1'
sg36
I7
sg37
F0.15674237052672263
sg38
I55
sg34
V3_ang_qs_trimF
p100
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p101
g48
(g50
S'\x06\x00\x00\x00'
tRp102
sg33
I85
sg15
I0
sg24
V1
sg16
F0.86167851069875212
sS'trials.thisRepN'
p103
I0
sS'trials.thisN'
p104
I6
sg39
F3.16766439909297
sg21
g11
sS'trials.thisTrialN'
p105
I6
sg40
V3_ang_qs_trimF.wav
p106
sg41
I14
sa(dp107
g14
S'1'
sg36
I8
sg37
F1.4242230970513805
sg38
I48
sg34
V3_hap_qs_trimF
p108
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p109
g48
(g50
S'\x07\x00\x00\x00'
tRp110
sg33
I78
sg15
I1
sg24
V1
sg16
F0.25948468678580383
sS'trials.thisRepN'
p111
I0
sS'trials.thisN'
p112
I7
sg39
F3.3681859410430799
sg21
g11
sS'trials.thisTrialN'
p113
I7
sg40
V3_hap_qs_trimF.wav
p114
sg41
I8
sa(dp115
g14
S'2'
sg36
I9
sg37
F-0.63412378462273378
sg38
I62
sg34
V3_fea_sw_trimF
p116
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p117
g48
(g50
S'\x08\x00\x00\x00'
tRp118
sg33
I92
sg15
I1
sg24
V1
sg16
F1.2968897629461722
sS'trials.thisRepN'
p119
I0
sS'trials.thisN'
p120
I8
sg39
F3.3168480725623501
sg21
g11
sS'trials.thisTrialN'
p121
I8
sg40
V3_fea_sw_trimF.wav
p122
sg41
I21
sa(dp123
g14
S'3'
sg36
I10
sg37
F-1.1293393049458027
sg38
I42
sg34
V1_hap_ss_trimF
p124
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p125
g48
(g50
S'\t\x00\x00\x00'
tRp126
sg33
I72
sg15
I0
sg24
V1
sg16
F1.1297609449055273
sS'trials.thisRepN'
p127
I0
sS'trials.thisN'
p128
I9
sg39
F3.8270294784580399
sg21
g11
sS'trials.thisTrialN'
p129
I9
sg40
V1_hap_ss_trimF.wav
p130
sg41
I2
sa(dp131
g14
S'2'
sg36
I11
sg37
F-0.3072020091293417
sg38
I44
sg34
V2_hap_qs_trimF_trimF
p132
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p133
g48
(g50
S'\n\x00\x00\x00'
tRp134
sg33
I74
sg15
I0
sg24
V1
sg16
F1.8103402601517757
sS'trials.thisRepN'
p135
I0
sS'trials.thisN'
p136
I10
sg39
F3.2894784580498797
sg21
g11
sS'trials.thisTrialN'
p137
I10
sg40
V2_hap_qs_trimF.wav
p138
sg41
I4
sa(dp139
g14
S'2'
sg36
I12
sg37
F-0.62197768686718324
sg38
I53
sg34
V2_ang_qs_trimF
p140
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p141
g48
(g50
S'\x0b\x00\x00\x00'
tRp142
sg33
I83
sg15
I0
sg24
V1
sg16
F1.4265493616794771
sS'trials.thisRepN'
p143
I0
sS'trials.thisN'
p144
I11
sg39
F3.5562358276643899
sg21
g11
sS'trials.thisTrialN'
p145
I11
sg40
V2_ang_qs_trimF.wav
p146
sg41
I12
sa(dp147
g14
S'2'
sg36
I13
sg37
F0.16624841156760786
sg38
I63
sg34
V2_fea_ss_trimF
p148
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p149
g48
(g50
S'\x0c\x00\x00\x00'
tRp150
sg33
I93
sg15
I1
sg24
V1
sg16
F1.3419746980942477
sS'trials.thisRepN'
p151
I0
sS'trials.thisN'
p152
I12
sg39
F3.0609977324263
sg21
g11
sS'trials.thisTrialN'
p153
I12
sg40
V2_fea_ss_trimF.wav
p154
sg41
I22
sa(dp155
g22
g23
sS'trials.thisIndex'
p156
g48
(g50
S'\r\x00\x00\x00'
tRp157
sg33
I94
sg15
I0
sg24
V1
sg14
Nsg36
I14
sS'trials.thisRepN'
p158
I0
sg42
g53
sg21
g11
sS'trials.thisN'
p159
I13
sg38
I64
sg39
F3.6325170068027202
sg34
V1_fea_ss_trimF
p160
sS'trials.thisTrialN'
p161
I13
sg40
V1_fea_ss_trimF.wav
p162
sg41
I23
sg37
F0.46505470843950819
sg19
g20
sg43
I2
sg35
g58
sa(dp163
g14
S'3'
sg36
I15
sg37
F0.80567575168831174
sg38
I57
sg34
V4_ang_qs_trimF
p164
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p165
g48
(g50
S'\x0e\x00\x00\x00'
tRp166
sg33
I87
sg15
I1
sg24
V1
sg16
F0.27023636108229709
sS'trials.thisRepN'
p167
I0
sS'trials.thisN'
p168
I14
sg39
F3.9615873015872998
sg21
g11
sS'trials.thisTrialN'
p169
I14
sg40
V4_ang_qs_trimF.wav
p170
sg41
I16
sa(dp171
g14
S'3'
sg36
I16
sg37
F1.4046911804528555
sg38
I59
sg34
V4_ang_ss_trimF
p172
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p173
g48
(g50
S'\x0f\x00\x00\x00'
tRp174
sg33
I89
sg15
I1
sg24
V1
sg16
F0.2403732361436397
sS'trials.thisRepN'
p175
I0
sS'trials.thisN'
p176
I15
sg39
F3.9851927437641699
sg21
g11
sS'trials.thisTrialN'
p177
I15
sg40
V4_ang_ss_trimF.wav
p178
sg41
I18
sa(dp179
g14
S'1'
sg36
I17
sg37
F0.063624465804048597
sg38
I45
sg34
V2_hap_sw_trimF
p180
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p181
g48
(g50
S'\x10\x00\x00\x00'
tRp182
sg33
I75
sg15
I1
sg24
V1
sg16
F0.74276224765284837
sS'trials.thisRepN'
p183
I0
sS'trials.thisN'
p184
I16
sg39
F3.18668934240362
sg21
g11
sS'trials.thisTrialN'
p185
I16
sg40
V2_hap_sw_trimF.wav
p186
sg41
I5
sa(dp187
g14
S'2'
sg36
I18
sg37
F0.78164074653547022
sg38
I65
sg34
V4_fea_qs_trimF
p188
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p189
g48
(g50
S'\x11\x00\x00\x00'
tRp190
sg33
I95
sg15
I1
sg24
V1
sg16
F0.38443938568825331
sS'trials.thisRepN'
p191
I0
sS'trials.thisN'
p192
I17
sg39
F3.9427210884353698
sg21
g11
sS'trials.thisTrialN'
p193
I17
sg40
V4_fea_qs_trimF.wav
p194
sg41
I24
sa(dp195
g14
S'1'
sg36
I19
sg37
F0.23169249593766542
sg38
I46
sg34
V3_hap_ss_trimF
p196
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p197
g48
(g50
S'\x12\x00\x00\x00'
tRp198
sg33
I76
sg15
I1
sg24
V1
sg16
F0.27017606652414372
sS'trials.thisRepN'
p199
I0
sS'trials.thisN'
p200
I18
sg39
F3.35551020408163
sg21
g11
sS'trials.thisTrialN'
p201
I18
sg40
V3_hap_ss_trimF.wav
p202
sg41
I6
sa(dp203
g14
S'3'
sg36
I20
sg37
F-0.7317971821406829
sg38
I52
sg34
V3_ang_qw_trimF
p204
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p205
g48
(g50
S'\x13\x00\x00\x00'
tRp206
sg33
I82
sg15
I1
sg24
V1
sg16
F1.4668479352000219
sS'trials.thisRepN'
p207
I0
sS'trials.thisN'
p208
I19
sg39
F2.8854421768707481
sg21
g11
sS'trials.thisTrialN'
p209
I19
sg40
V3_ang_qw_trimF.wav
p210
sg41
I11
sa(dp211
g14
S'3'
sg36
I21
sg37
F1.2549373232617196
sg38
I58
sg34
V1_ang_ss_trimF
p212
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p213
g48
(g50
S'\x14\x00\x00\x00'
tRp214
sg33
I88
sg15
I1
sg24
V1
sg16
F1.1041428134338958
sS'trials.thisRepN'
p215
I0
sS'trials.thisN'
p216
I20
sg39
F3.54068027210884
sg21
g11
sS'trials.thisTrialN'
p217
I20
sg40
V1_ang_ss_trimF.wav
p218
sg41
I17
sa(dp219
g14
S'2'
sg36
I22
sg37
F-1.1913061482898895
sg38
I61
sg34
V3_fea_qs_trimF
p220
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p221
g48
(g50
S'\x15\x00\x00\x00'
tRp222
sg33
I91
sg15
I1
sg24
V1
sg16
F0.3331152466336107
sS'trials.thisRepN'
p223
I0
sS'trials.thisN'
p224
I21
sg39
F3.7509750566893398
sg21
g11
sS'trials.thisTrialN'
p225
I21
sg40
V3_fea_qs_trimF.wav
p226
sg41
I20
sa(dp227
g14
S'2'
sg36
I23
sg37
F-1.5491056174137092
sg38
I60
sg34
V3_fea_ss_trimF
p228
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p229
g48
(g50
S'\x16\x00\x00\x00'
tRp230
sg33
I90
sg15
I1
sg24
V1
sg16
F0.34890215796788482
sS'trials.thisRepN'
p231
I0
sS'trials.thisN'
p232
I22
sg39
F3.30308390022675
sg21
g11
sS'trials.thisTrialN'
p233
I22
sg40
V3_fea_ss_trimF.wav
p234
sg41
I19
sa(dp235
g14
S'1'
sg36
I24
sg37
F1.3965527081060551
sg38
I47
sg34
V3_hap_qw_trimF
p236
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p237
g48
(g50
S'\x17\x00\x00\x00'
tRp238
sg33
I77
sg15
I1
sg24
V1
sg16
F1.2499825209924467
sS'trials.thisRepN'
p239
I0
sS'trials.thisN'
p240
I23
sg39
F3.0733333333333297
sg21
g11
sS'trials.thisTrialN'
p241
I23
sg40
V3_hap_qw_trimF.wav
p242
sg41
I7
sa(dp243
g14
S'3'
sg36
I25
sg37
F-1.0313048965229548
sg38
I51
sg34
V2_ang_ss_trimF
p244
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p245
g48
(g50
S'\x18\x00\x00\x00'
tRp246
sg33
I81
sg15
I1
sg24
V1
sg16
F0.27498167109575888
sS'trials.thisRepN'
p247
I0
sS'trials.thisN'
p248
I24
sg39
F3.6721768707482898
sg21
g11
sS'trials.thisTrialN'
p249
I24
sg40
V2_ang_ss_trimF.wav
p250
sg41
I10
sa(dp251
g14
S'3'
sg36
I26
sg37
F0.65592189449717464
sg38
I56
sg34
V4_ang_sw_trimF
p252
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p253
g48
(g50
S'\x19\x00\x00\x00'
tRp254
sg33
I86
sg15
I1
sg24
V1
sg16
F0.27649416650150727
sS'trials.thisRepN'
p255
I0
sS'trials.thisN'
p256
I25
sg39
F3.4781405895691599
sg21
g11
sS'trials.thisTrialN'
p257
I25
sg40
V4_ang_sw_trimF.wav
p258
sg41
I15
sa(dp259
g14
S'2'
sg36
I27
sg37
F0.97211157047895325
sg38
I66
sg34
g55
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p260
g48
(g50
S'\x1a\x00\x00\x00'
tRp261
sg33
I96
sg15
I1
sg24
V1
sg16
F1.2281385722889979
sS'trials.thisRepN'
p262
I0
sS'trials.thisN'
p263
I26
sg39
F2.688027210884353
sg21
g11
sS'trials.thisTrialN'
p264
I26
sg40
g57
sg41
I25
sa(dp265
g22
g23
sS'trials.thisIndex'
p266
g48
(g50
S'\x1b\x00\x00\x00'
tRp267
sg33
I80
sg15
I0
sg24
V1
sg14
Nsg36
I28
sS'trials.thisRepN'
p268
I0
sg42
g53
sg21
g11
sS'trials.thisN'
p269
I27
sg38
I50
sg39
F3.5404761904761903
sg34
g64
sS'trials.thisTrialN'
p270
I27
sg40
g66
sg41
I9
sg37
F-1.4805664680963626
sg19
g20
sg43
I3
sg35
g58
sa(dp271
g14
S'2'
sg36
I29
sg37
F0.98948011330479291
sg38
I67
sg34
g72
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p272
g48
(g50
S'\x1c\x00\x00\x00'
tRp273
sg33
I97
sg15
I1
sg24
V1
sg16
F0.42599324059517585
sS'trials.thisRepN'
p274
I0
sS'trials.thisN'
p275
I28
sg39
F3.0989115646258503
sg21
g11
sS'trials.thisTrialN'
p276
I28
sg40
g74
sg41
I26
sa(dp277
g14
S'3'
sg36
I30
sg37
F-0.41232228679959398
sg38
I54
sg34
g76
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p278
g48
(g50
S'\x1d\x00\x00\x00'
tRp279
sg33
I84
sg15
I1
sg24
V1
sg16
F0.66825164382851199
sS'trials.thisRepN'
p280
I0
sS'trials.thisN'
p281
I29
sg39
F3.1113832199546403
sg21
g11
sS'trials.thisTrialN'
p282
I29
sg40
g82
sg41
I13
sa(dp283
g14
S'3'
sg36
I31
sg37
F-0.53706073129766818
sg38
I43
sg34
g84
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p284
g48
(g50
S'\x1e\x00\x00\x00'
tRp285
sg33
I73
sg15
I0
sg24
V1
sg16
F1.5616110962512835
sS'trials.thisRepN'
p286
I0
sS'trials.thisN'
p287
I30
sg39
F3.75081632653061
sg21
g11
sS'trials.thisTrialN'
p288
I30
sg40
g90
sg41
I3
sa(dp289
g14
S'2'
sg36
I32
sg37
F-1.1424907215263371
sg38
I41
sg34
g92
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p290
g48
(g50
S'\x1f\x00\x00\x00'
tRp291
sg33
I71
sg15
I0
sg24
V1
sg16
F0.75224517050210693
sS'trials.thisRepN'
p292
I0
sS'trials.thisN'
p293
I31
sg39
F3.13696145124716
sg21
g11
sS'trials.thisTrialN'
p294
I31
sg40
g98
sg41
I1
sa(dp295
g14
S'3'
sg36
I33
sg37
F0.15674237052672263
sg38
I55
sg34
g100
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p296
g48
(g50
S' \x00\x00\x00'
tRp297
sg33
I85
sg15
I1
sg24
V1
sg16
F0.98755238089741226
sS'trials.thisRepN'
p298
I0
sS'trials.thisN'
p299
I32
sg39
F3.16766439909297
sg21
g11
sS'trials.thisTrialN'
p300
I32
sg40
g106
sg41
I14
sa(dp301
g14
S'1'
sg36
I34
sg37
F1.4242230970513805
sg38
I48
sg34
g108
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p302
g48
(g50
S'!\x00\x00\x00'
tRp303
sg33
I78
sg15
I1
sg24
V1
sg16
F0.23358817405626553
sS'trials.thisRepN'
p304
I0
sS'trials.thisN'
p305
I33
sg39
F3.3681859410430799
sg21
g11
sS'trials.thisTrialN'
p306
I33
sg40
g114
sg41
I8
sa(dp307
g14
S'2'
sg36
I35
sg37
F-0.63412378462273378
sg38
I62
sg34
g116
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p308
g48
(g50
S'"\x00\x00\x00'
tRp309
sg33
I92
sg15
I1
sg24
V1
sg16
F0.85659580773219091
sS'trials.thisRepN'
p310
I0
sS'trials.thisN'
p311
I34
sg39
F3.3168480725623501
sg21
g11
sS'trials.thisTrialN'
p312
I34
sg40
g122
sg41
I21
sa(dp313
g14
S'3'
sg36
I36
sg37
F-1.1293393049458027
sg38
I42
sg34
g124
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p314
g48
(g50
S'#\x00\x00\x00'
tRp315
sg33
I72
sg15
I0
sg24
V1
sg16
F0.23016998575380399
sS'trials.thisRepN'
p316
I0
sS'trials.thisN'
p317
I35
sg39
F3.8270294784580399
sg21
g11
sS'trials.thisTrialN'
p318
I35
sg40
g130
sg41
I2
sa(dp319
g22
g23
sS'trials.thisIndex'
p320
g48
(g50
S'$\x00\x00\x00'
tRp321
sg33
I74
sg15
I0
sg24
V1
sg14
Nsg36
I37
sS'trials.thisRepN'
p322
I0
sg42
g53
sg21
g11
sS'trials.thisN'
p323
I36
sg38
I44
sg39
F3.2894784580498797
sg34
g132
sS'trials.thisTrialN'
p324
I36
sg40
g138
sg41
I4
sg37
F-0.3072020091293417
sg19
g20
sg43
I1
sg35
g58
sa(dp325
g14
S'2'
sg36
I38
sg37
F-0.62197768686718324
sg38
I53
sg34
g140
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p326
g48
(g50
S'%\x00\x00\x00'
tRp327
sg33
I83
sg15
I0
sg24
V1
sg16
F0.78112690529198403
sS'trials.thisRepN'
p328
I0
sS'trials.thisN'
p329
I37
sg39
F3.5562358276643899
sg21
g11
sS'trials.thisTrialN'
p330
I37
sg40
g146
sg41
I12
sa(dp331
g14
S'2'
sg36
I39
sg37
F0.16624841156760786
sg38
I63
sg34
g148
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p332
g48
(g50
S'&\x00\x00\x00'
tRp333
sg33
I93
sg15
I1
sg24
V1
sg16
F0.21998405401365062
sS'trials.thisRepN'
p334
I0
sS'trials.thisN'
p335
I38
sg39
F3.0609977324263
sg21
g11
sS'trials.thisTrialN'
p336
I38
sg40
g154
sg41
I22
sa(dp337
g14
S'2'
sg36
I40
sg37
F0.46505470843950819
sg38
I64
sg34
g160
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p338
g48
(g50
S"'\x00\x00\x00"
tRp339
sg33
I94
sg15
I1
sg24
V1
sg16
F0.74246847203968969
sS'trials.thisRepN'
p340
I0
sS'trials.thisN'
p341
I39
sg39
F3.6325170068027202
sg21
g11
sS'trials.thisTrialN'
p342
I39
sg40
g162
sg41
I23
sa(dp343
g14
S'3'
sg36
I41
sg37
F0.80567575168831174
sg38
I57
sg34
g164
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p344
g48
(g50
S'(\x00\x00\x00'
tRp345
sg33
I87
sg15
I1
sg24
V1
sg16
F0.35032292867347792
sS'trials.thisRepN'
p346
I0
sS'trials.thisN'
p347
I40
sg39
F3.9615873015872998
sg21
g11
sS'trials.thisTrialN'
p348
I40
sg40
g170
sg41
I16
sa(dp349
g14
S'3'
sg36
I42
sg37
F1.4046911804528555
sg38
I59
sg34
g172
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p350
g48
(g50
S')\x00\x00\x00'
tRp351
sg33
I89
sg15
I1
sg24
V1
sg16
F0.55900496018955437
sS'trials.thisRepN'
p352
I0
sS'trials.thisN'
p353
I41
sg39
F3.9851927437641699
sg21
g11
sS'trials.thisTrialN'
p354
I41
sg40
g178
sg41
I18
sa(dp355
g14
S'1'
sg36
I43
sg37
F0.063624465804048597
sg38
I45
sg34
g180
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p356
g48
(g50
S'*\x00\x00\x00'
tRp357
sg33
I75
sg15
I1
sg24
V1
sg16
F0.74863775991605053
sS'trials.thisRepN'
p358
I0
sS'trials.thisN'
p359
I42
sg39
F3.18668934240362
sg21
g11
sS'trials.thisTrialN'
p360
I42
sg40
g186
sg41
I5
sa(dp361
g14
S'2'
sg36
I44
sg37
F0.78164074653547022
sg38
I65
sg34
g188
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p362
g48
(g50
S'+\x00\x00\x00'
tRp363
sg33
I95
sg15
I1
sg24
V1
sg16
F0.79360852026249518
sS'trials.thisRepN'
p364
I0
sS'trials.thisN'
p365
I43
sg39
F3.9427210884353698
sg21
g11
sS'trials.thisTrialN'
p366
I43
sg40
g194
sg41
I24
sa(dp367
g14
S'1'
sg36
I45
sg37
F0.23169249593766542
sg38
I46
sg34
g196
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p368
g48
(g50
S',\x00\x00\x00'
tRp369
sg33
I76
sg15
I1
sg24
V1
sg16
F0.094384716484086084
sS'trials.thisRepN'
p370
I0
sS'trials.thisN'
p371
I44
sg39
F3.35551020408163
sg21
g11
sS'trials.thisTrialN'
p372
I44
sg40
g202
sg41
I6
sa(dp373
g14
S'1'
sg36
I46
sg37
F-0.7317971821406829
sg38
I52
sg34
g204
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p374
g48
(g50
S'-\x00\x00\x00'
tRp375
sg33
I82
sg15
I0
sg24
V1
sg16
F0.54991266910539593
sS'trials.thisRepN'
p376
I0
sS'trials.thisN'
p377
I45
sg39
F2.8854421768707481
sg21
g11
sS'trials.thisTrialN'
p378
I45
sg40
g210
sg41
I11
sa(dp379
g14
S'4'
sg36
I47
sg37
F1.2549373232617196
sg38
I58
sg34
g212
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p380
g48
(g50
S'.\x00\x00\x00'
tRp381
sg33
I88
sg15
I0
sg24
V1
sg16
F1.0718031215903636
sS'trials.thisRepN'
p382
I0
sS'trials.thisN'
p383
I46
sg39
F3.54068027210884
sg21
g11
sS'trials.thisTrialN'
p384
I46
sg40
g218
sg41
I17
sa(dp385
g14
S'4'
sg36
I48
sg37
F-1.1913061482898895
sg38
I61
sg34
g220
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p386
g48
(g50
S'/\x00\x00\x00'
tRp387
sg33
I91
sg15
I0
sg24
V1
sg16
F0.2300442651857395
sS'trials.thisRepN'
p388
I0
sS'trials.thisN'
p389
I47
sg39
F3.7509750566893398
sg21
g11
sS'trials.thisTrialN'
p390
I47
sg40
g226
sg41
I20
sa(dp391
g14
S'4'
sg36
I49
sg37
F-1.5491056174137092
sg38
I60
sg34
g228
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p392
g48
(g50
S'0\x00\x00\x00'
tRp393
sg33
I90
sg15
I0
sg24
V1
sg16
F0.19470331549513276
sS'trials.thisRepN'
p394
I0
sS'trials.thisN'
p395
I48
sg39
F3.30308390022675
sg21
g11
sS'trials.thisTrialN'
p396
I48
sg40
g234
sg41
I19
sa(dp397
g14
S'4'
sg36
I50
sg37
F1.3965527081060551
sg38
I47
sg34
g236
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p398
g48
(g50
S'1\x00\x00\x00'
tRp399
sg33
I77
sg15
I0
sg24
V1
sg16
F0.050125303637628349
sS'trials.thisRepN'
p400
I0
sS'trials.thisN'
p401
I49
sg39
F3.0733333333333297
sg21
g11
sS'trials.thisTrialN'
p402
I49
sg40
g242
sg41
I7
sa(dp403
g14
S'3'
sg36
I51
sg37
F-1.0313048965229548
sg38
I51
sg34
g244
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p404
g48
(g50
S'2\x00\x00\x00'
tRp405
sg33
I81
sg15
I1
sg24
V1
sg16
F0.34630371908380653
sS'trials.thisRepN'
p406
I0
sS'trials.thisN'
p407
I50
sg39
F3.6721768707482898
sg21
g11
sS'trials.thisTrialN'
p408
I50
sg40
g250
sg41
I10
sa(dp409
g14
S'3'
sg36
I52
sg37
F0.65592189449717464
sg38
I56
sg34
g252
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p410
g48
(g50
S'3\x00\x00\x00'
tRp411
sg33
I86
sg15
I1
sg24
V1
sg16
F0.20839210449176448
sS'trials.thisRepN'
p412
I0
sS'trials.thisN'
p413
I51
sg39
F3.4781405895691599
sg21
g11
sS'trials.thisTrialN'
p414
I51
sg40
g258
sg41
I15
sa(dp415
g14
S'2'
sg36
I53
sg37
F0.97211157047895325
sg38
I66
sg34
g55
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p416
g48
(g50
S'4\x00\x00\x00'
tRp417
sg33
I96
sg15
I1
sg24
V1
sg16
F0.48806007390575701
sS'trials.thisRepN'
p418
I0
sS'trials.thisN'
p419
I52
sg39
F2.688027210884353
sg21
g11
sS'trials.thisTrialN'
p420
I52
sg40
g57
sg41
I25
sa(dp421
g14
S'2'
sg36
I54
sg37
F-1.4805664680963626
sg38
I50
sg34
g64
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p422
g48
(g50
S'5\x00\x00\x00'
tRp423
sg33
I80
sg15
I0
sg24
V1
sg16
F0.15491147283569262
sS'trials.thisRepN'
p424
I0
sS'trials.thisN'
p425
I53
sg39
F3.5404761904761903
sg21
g11
sS'trials.thisTrialN'
p426
I53
sg40
g66
sg41
I9
sa(dp427
g14
S'2'
sg36
I55
sg37
F0.98948011330479291
sg38
I67
sg34
g72
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p428
g48
(g50
S'6\x00\x00\x00'
tRp429
sg33
I97
sg15
I1
sg24
V1
sg16
F0.078701075616436356
sS'trials.thisRepN'
p430
I0
sS'trials.thisN'
p431
I54
sg39
F3.0989115646258503
sg21
g11
sS'trials.thisTrialN'
p432
I54
sg40
g74
sg41
I26
sa(dp433
g14
S'3'
sg36
I56
sg37
F-0.41232228679959398
sg38
I54
sg34
g76
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p434
g48
(g50
S'7\x00\x00\x00'
tRp435
sg33
I84
sg15
I1
sg24
V1
sg16
F1.4693809480741891
sS'trials.thisRepN'
p436
I0
sS'trials.thisN'
p437
I55
sg39
F3.1113832199546403
sg21
g11
sS'trials.thisTrialN'
p438
I55
sg40
g82
sg41
I13
sa(dp439
g14
S'3'
sg36
I57
sg37
F-0.53706073129766818
sg38
I43
sg34
g84
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p440
g48
(g50
S'8\x00\x00\x00'
tRp441
sg33
I73
sg15
I0
sg24
V1
sg16
F0.22385252720789595
sS'trials.thisRepN'
p442
I0
sS'trials.thisN'
p443
I56
sg39
F3.75081632653061
sg21
g11
sS'trials.thisTrialN'
p444
I56
sg40
g90
sg41
I3
sa(dp445
g14
S'2'
sg36
I58
sg37
F-1.1424907215263371
sg38
I41
sg34
g92
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p446
g48
(g50
S'9\x00\x00\x00'
tRp447
sg33
I71
sg15
I0
sg24
V1
sg16
F0.24912749284322899
sS'trials.thisRepN'
p448
I0
sS'trials.thisN'
p449
I57
sg39
F3.13696145124716
sg21
g11
sS'trials.thisTrialN'
p450
I57
sg40
g98
sg41
I1
sa(dp451
g14
S'1'
sg36
I59
sg37
F0.15674237052672263
sg38
I55
sg34
g100
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p452
g48
(g50
S':\x00\x00\x00'
tRp453
sg33
I85
sg15
I0
sg24
V1
sg16
F0.23379599785249638
sS'trials.thisRepN'
p454
I0
sS'trials.thisN'
p455
I58
sg39
F3.16766439909297
sg21
g11
sS'trials.thisTrialN'
p456
I58
sg40
g106
sg41
I14
sa(dp457
g14
S'1'
sg36
I60
sg37
F1.4242230970513805
sg38
I48
sg34
g108
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p458
g48
(g50
S';\x00\x00\x00'
tRp459
sg33
I78
sg15
I1
sg24
V1
sg16
F0.091867097965177891
sS'trials.thisRepN'
p460
I0
sS'trials.thisN'
p461
I59
sg39
F3.3681859410430799
sg21
g11
sS'trials.thisTrialN'
p462
I59
sg40
g114
sg41
I8
sa(dp463
g14
S'2'
sg36
I61
sg37
F-0.63412378462273378
sg38
I62
sg34
g116
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p464
g48
(g50
S'<\x00\x00\x00'
tRp465
sg33
I92
sg15
I1
sg24
V1
sg16
F0.37869921546518981
sS'trials.thisRepN'
p466
I0
sS'trials.thisN'
p467
I60
sg39
F3.3168480725623501
sg21
g11
sS'trials.thisTrialN'
p468
I60
sg40
g122
sg41
I21
sa(dp469
g14
S'3'
sg36
I62
sg37
F-1.1293393049458027
sg38
I42
sg34
g124
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p470
g48
(g50
S'=\x00\x00\x00'
tRp471
sg33
I72
sg15
I0
sg24
V1
sg16
F0.23866446270812958
sS'trials.thisRepN'
p472
I0
sS'trials.thisN'
p473
I61
sg39
F3.8270294784580399
sg21
g11
sS'trials.thisTrialN'
p474
I61
sg40
g130
sg41
I2
sa(dp475
g14
S'2'
sg36
I63
sg37
F-0.3072020091293417
sg38
I44
sg34
g132
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p476
g48
(g50
S'>\x00\x00\x00'
tRp477
sg33
I74
sg15
I0
sg24
V1
sg16
F1.1992998134075776
sS'trials.thisRepN'
p478
I0
sS'trials.thisN'
p479
I62
sg39
F3.2894784580498797
sg21
g11
sS'trials.thisTrialN'
p480
I62
sg40
g138
sg41
I4
sa(dp481
g14
S'1'
sg36
I64
sg37
F-0.62197768686718324
sg38
I53
sg34
g140
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p482
g48
(g50
S'?\x00\x00\x00'
tRp483
sg33
I83
sg15
I0
sg24
V1
sg16
F0.36169230147532971
sS'trials.thisRepN'
p484
I0
sS'trials.thisN'
p485
I63
sg39
F3.5562358276643899
sg21
g11
sS'trials.thisTrialN'
p486
I63
sg40
g146
sg41
I12
sa(dp487
g14
S'2'
sg36
I65
sg37
F0.16624841156760786
sg38
I63
sg34
g148
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p488
g48
(g50
S'@\x00\x00\x00'
tRp489
sg33
I93
sg15
I1
sg24
V1
sg16
F0.19642106897117628
sS'trials.thisRepN'
p490
I0
sS'trials.thisN'
p491
I64
sg39
F3.0609977324263
sg21
g11
sS'trials.thisTrialN'
p492
I64
sg40
g154
sg41
I22
sa(dp493
g14
S'3'
sg36
I66
sg37
F0.46505470843950819
sg38
I64
sg34
g160
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p494
g48
(g50
S'A\x00\x00\x00'
tRp495
sg33
I94
sg15
I0
sg24
V1
sg16
F0.78672275343438969
sS'trials.thisRepN'
p496
I0
sS'trials.thisN'
p497
I65
sg39
F3.6325170068027202
sg21
g11
sS'trials.thisTrialN'
p498
I65
sg40
g162
sg41
I23
sa(dp499
g14
S'3'
sg36
I67
sg37
F0.80567575168831174
sg38
I57
sg34
g164
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p500
g48
(g50
S'B\x00\x00\x00'
tRp501
sg33
I87
sg15
I1
sg24
V1
sg16
F0.56568418608441107
sS'trials.thisRepN'
p502
I0
sS'trials.thisN'
p503
I66
sg39
F3.9615873015872998
sg21
g11
sS'trials.thisTrialN'
p504
I66
sg40
g170
sg41
I16
sa(dp505
g14
S'3'
sg36
I68
sg37
F1.4046911804528555
sg38
I59
sg34
g172
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p506
g48
(g50
S'C\x00\x00\x00'
tRp507
sg33
I89
sg15
I1
sg24
V1
sg16
F0.2088635566220205
sS'trials.thisRepN'
p508
I0
sS'trials.thisN'
p509
I67
sg39
F3.9851927437641699
sg21
g11
sS'trials.thisTrialN'
p510
I67
sg40
g178
sg41
I18
sa(dp511
g14
S'1'
sg36
I69
sg37
F0.063624465804048597
sg38
I45
sg34
g180
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p512
g48
(g50
S'D\x00\x00\x00'
tRp513
sg33
I75
sg15
I1
sg24
V1
sg16
F0.80319727930427121
sS'trials.thisRepN'
p514
I0
sS'trials.thisN'
p515
I68
sg39
F3.18668934240362
sg21
g11
sS'trials.thisTrialN'
p516
I68
sg40
g186
sg41
I5
sa(dp517
g14
S'2'
sg36
I70
sg37
F0.78164074653547022
sg38
I65
sg34
g188
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p518
g48
(g50
S'E\x00\x00\x00'
tRp519
sg33
I95
sg15
I1
sg24
V1
sg16
F0.15188519916125642
sS'trials.thisRepN'
p520
I0
sS'trials.thisN'
p521
I69
sg39
F3.9427210884353698
sg21
g11
sS'trials.thisTrialN'
p522
I69
sg40
g194
sg41
I24
sa(dp523
g14
S'1'
sg36
I71
sg37
F0.23169249593766542
sg38
I46
sg34
g196
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p524
g48
(g50
S'F\x00\x00\x00'
tRp525
sg33
I76
sg15
I1
sg24
V1
sg16
F0.75595007867156028
sS'trials.thisRepN'
p526
I0
sS'trials.thisN'
p527
I70
sg39
F3.35551020408163
sg21
g11
sS'trials.thisTrialN'
p528
I70
sg40
g202
sg41
I6
sa(dp529
g14
S'3'
sg36
I72
sg37
F-0.7317971821406829
sg38
I52
sg34
g204
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p530
g48
(g50
S'G\x00\x00\x00'
tRp531
sg33
I82
sg15
I1
sg24
V1
sg16
F0.22528484367992974
sS'trials.thisRepN'
p532
I0
sS'trials.thisN'
p533
I71
sg39
F2.8854421768707481
sg21
g11
sS'trials.thisTrialN'
p534
I71
sg40
g210
sg41
I11
sa(dp535
g14
S'3'
sg36
I73
sg37
F1.2549373232617196
sg38
I58
sg34
g212
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p536
g48
(g50
S'H\x00\x00\x00'
tRp537
sg33
I88
sg15
I1
sg24
V1
sg16
F0.052383783842714138
sS'trials.thisRepN'
p538
I0
sS'trials.thisN'
p539
I72
sg39
F3.54068027210884
sg21
g11
sS'trials.thisTrialN'
p540
I72
sg40
g218
sg41
I17
sa(dp541
g14
S'2'
sg36
I74
sg37
F-1.1913061482898895
sg38
I61
sg34
g220
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p542
g48
(g50
S'I\x00\x00\x00'
tRp543
sg33
I91
sg15
I1
sg24
V1
sg16
F0.27196052887308042
sS'trials.thisRepN'
p544
I0
sS'trials.thisN'
p545
I73
sg39
F3.7509750566893398
sg21
g11
sS'trials.thisTrialN'
p546
I73
sg40
g226
sg41
I20
sa(dp547
g14
S'2'
sg36
I75
sg37
F-1.5491056174137092
sg38
I60
sg34
g228
sg42
g53
sg19
g20
sg43
I2
sg35
g58
sg22
g23
sS'trials.thisIndex'
p548
g48
(g50
S'J\x00\x00\x00'
tRp549
sg33
I90
sg15
I1
sg24
V1
sg16
F0.23944187764951153
sS'trials.thisRepN'
p550
I0
sS'trials.thisN'
p551
I74
sg39
F3.30308390022675
sg21
g11
sS'trials.thisTrialN'
p552
I74
sg40
g234
sg41
I19
sa(dp553
g14
S'1'
sg36
I76
sg37
F1.3965527081060551
sg38
I47
sg34
g236
sg42
g53
sg19
g20
sg43
I1
sg35
g58
sg22
g23
sS'trials.thisIndex'
p554
g48
(g50
S'K\x00\x00\x00'
tRp555
sg33
I77
sg15
I1
sg24
V1
sg16
F0.2288255453931356
sS'trials.thisRepN'
p556
I0
sS'trials.thisN'
p557
I75
sg39
F3.0733333333333297
sg21
g11
sS'trials.thisTrialN'
p558
I75
sg40
g242
sg41
I7
sa(dp559
g14
S'1'
sg36
I77
sg37
F-1.0313048965229548
sg38
I51
sg34
g244
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p560
g48
(g50
S'L\x00\x00\x00'
tRp561
sg33
I81
sg15
I0
sg24
V1
sg16
F0.52940418072202533
sS'trials.thisRepN'
p562
I0
sS'trials.thisN'
p563
I76
sg39
F3.6721768707482898
sg21
g11
sS'trials.thisTrialN'
p564
I76
sg40
g250
sg41
I10
sa(dp565
g14
S'3'
sg36
I78
sg37
F0.65592189449717464
sg38
I56
sg34
g252
sg42
g53
sg19
g20
sg43
I3
sg35
g58
sg22
g23
sS'trials.thisIndex'
p566
g48
(g50
S'M\x00\x00\x00'
tRp567
sg33
I86
sg15
I1
sg24
V1
sg16
F0.27204968784738526
sS'trials.thisRepN'
p568
I0
sS'trials.thisN'
p569
I77
sg39
F3.4781405895691599
sg21
g11
sS'trials.thisTrialN'
p570
I77
sg40
g258
sg41
I15
sasS'loops'
p571
(lp572
g1
(cpsychopy.data
TrialHandler
p573
g3
NtRp574
(dp575
S'origin'
p576
V# -*- coding: utf-8 -*-\u000a"""Routines for handling data structures and analysis"""\u000a# Part of the PsychoPy library\u000a# Copyright (C) 2012 Jonathan Peirce\u000a# Distributed under the terms of the GNU General Public License (GPL).\u000a\u000afrom psychopy import misc, gui, logging\u000aimport psychopy\u000aimport cPickle, string, sys, platform, os, time, copy, csv\u000aimport numpy\u000afrom scipy import optimize, special\u000afrom matplotlib import mlab    #used for importing csv files\u000afrom contrib.quest import *    #used for QuestHandler\u000aimport inspect #so that Handlers can find the script that called them\u000aimport codecs, locale\u000aimport weakref\u000aimport re\u000a\u000atry:\u000a    import openpyxl\u000a    from openpyxl.cell import get_column_letter\u000a    from openpyxl.reader.excel import load_workbook\u000a    haveOpenpyxl=True\u000aexcept:\u000a    haveOpenpyxl=False\u000a\u000a_experiments=weakref.WeakValueDictionary()\u000a_nonalphanumeric_re = re.compile(r'\u005cW') # will match all bad var name chars\u000a\u000aclass ExperimentHandler(object):\u000a    """A container class for keeping track of multiple loops/handlers\u000a\u000a    Useful for generating a single data file from an experiment with many\u000a    different loops (e.g. interleaved staircases or loops within loops\u000a\u000a    :usage:\u000a\u000a        exp = data.ExperimentHandler(name="Face Preference",version='0.1.0')\u000a\u000a    """\u000a    def __init__(self,\u000a                name='',\u000a                version='',\u000a                extraInfo=None,\u000a                runtimeInfo=None,\u000a                originPath=None,\u000a                savePickle=True,\u000a                saveWideText=True,\u000a                dataFileName=''):\u000a        """\u000a        :parameters:\u000a\u000a            name : a string or unicode\u000a                As a useful identifier later\u000a\u000a            version : usually a string (e.g. '1.1.0')\u000a                To keep track of which version of the experiment was run\u000a\u000a            extraInfo : a dictionary\u000a                Containing useful information about this run\u000a                (e.g. {'participant':'jwp','gender':'m','orientation':90} )\u000a\u000a            runtimeInfo : :class:`psychopy.info.RunTimeInfo`\u000a                Containining information about the system as detected at runtime\u000a\u000a            originPath : string or unicode\u000a                The path and filename of the originating script/experiment\u000a                If not provided this will be determined as the path of the\u000a                calling script.\u000a\u000a            dataFilename : string\u000a                This is defined in advance and the file will be saved at any\u000a                point that the handler is removed or discarded (unless .abort()\u000a                had been called in advance).\u000a                The handler will attempt to populate the file even in the\u000a                event of a (not too serious) crash!\u000a\u000a        """\u000a        self.loops=[]\u000a        self.loopsUnfinished=[]\u000a        self.name=name\u000a        self.version=version\u000a        self.runtimeInfo=runtimeInfo\u000a        if extraInfo==None:\u000a            self.extraInfo = {}\u000a        else:\u000a            self.extraInfo=extraInfo\u000a        self.originPath=originPath\u000a        self.savePickle=savePickle\u000a        self.saveWideText=saveWideText\u000a        self.dataFileName=dataFileName\u000a        self.thisEntry = {}\u000a        self.entries=[]#chronological list of entries\u000a        self._paramNamesSoFar=[]\u000a        self.dataNames=[]#names of all the data (eg. resp.keys)\u000a        if dataFileName in ['', None]:\u000a            logging.warning('ExperimentHandler created with no dataFileName parameter. No data will be saved in the event of a crash')\u000a    def __del__(self):\u000a        if self.dataFileName not in ['', None]:\u000a            logging.debug('Saving data for %s ExperimentHandler' %self.name)\u000a            if self.savePickle==True:\u000a                self.saveAsPickle(self.dataFileName)\u000a            if self.saveWideText==True:\u000a                self.saveAsWideText(self.dataFileName+'.csv', delim=',')\u000a    def addLoop(self, loopHandler):\u000a        """Add a loop such as a `~psychopy.data.TrialHandler` or `~psychopy.data.StairHandler`\u000a        Data from this loop will be included in the resulting data files.\u000a        """\u000a        self.loops.append(loopHandler)\u000a        self.loopsUnfinished.append(loopHandler)\u000a        #keep the loop updated that is now owned\u000a        loopHandler.setExp(self)\u000a    def loopEnded(self, loopHandler):\u000a        """Informs the experiment handler that the loop is finished and not to\u000a        include its values in further entries of the experiment.\u000a\u000a        This method is called by the loop itself if it ends its iterations,\u000a        so is not typically needed by the user.\u000a        """\u000a        if loopHandler in self.loopsUnfinished:\u000a            self.loopsUnfinished.remove(loopHandler)\u000a    def _getAllParamNames(self):\u000a        """Returns the attribute names of loop parameters (trialN etc)\u000a        that the current set of loops contain, ready to build a wide-format\u000a        data file.\u000a        """\u000a        names=copy.deepcopy(self._paramNamesSoFar)\u000a        #get names (or identifiers) for all contained loops\u000a        for thisLoop in self.loops:\u000a            theseNames, vals = self._getLoopInfo(thisLoop)\u000a            for name in theseNames:\u000a                if name not in names:\u000a                    names.append(name)\u000a        return names\u000a    def _getExtraInfo(self):\u000a        """\u000a        Get the names and vals from the extraInfo dict (if it exists)\u000a        """\u000a        if type(self.extraInfo) != dict:\u000a            names=[]\u000a            vals=[]\u000a        else:\u000a            names=self.extraInfo.keys()\u000a            vals= self.extraInfo.values()\u000a        return names, vals\u000a    def _getLoopInfo(self, loop):\u000a        """Returns the attribute names and values for the current trial of a particular loop.\u000a        Does not return data inputs from the subject, only info relating to the trial\u000a        execution.\u000a        """\u000a        names=[]\u000a        vals=[]\u000a        name = loop.name\u000a        #standard attributes\u000a        for attr in ['thisRepN', 'thisTrialN', 'thisN','thisIndex', 'stepSizeCurrent']:\u000a            if hasattr(loop, attr):\u000a                if attr=='stepSizeCurrent':\u000a                    attrName=name+'.stepSize'\u000a                else:\u000a                    attrName = name+'.'+attr\u000a                #append the attribute name and the current value\u000a                names.append(attrName)\u000a                vals.append(getattr(loop,attr))\u000a\u000a        if hasattr(loop, 'thisTrial'):\u000a            trial = loop.thisTrial\u000a            if hasattr(trial,'items'):#is a TrialList object or a simple dict\u000a                for attr,val in trial.items():\u000a                    if attr not in self._paramNamesSoFar: self._paramNamesSoFar.append(attr)\u000a                    names.append(attr)\u000a                    vals.append(val)\u000a            elif trial==[]:#we haven't had 1st trial yet? Not actually sure why this occasionally happens (JWP)\u000a                pass\u000a            else:\u000a                names.append(name+'.thisTrial')\u000a                vals.append(trial)\u000a        elif hasattr(loop, 'intensities'):\u000a            names.append(name+'.intensity')\u000a            if len(loop.intensities)>0:\u000a                vals.append(loop.intensities[-1])\u000a            else:\u000a                vals.append(None)\u000a\u000a        return names, vals\u000a    def addData(self, name, value):\u000a        """Add the data with a given name to the current experiment.\u000a\u000a        Typically the user does not need to use this function; if you added\u000a        your data to the loop and had already added the loop to the\u000a        experiment then the loop will automatically inform the experiment\u000a        that it has received data.\u000a\u000a        Multiple data name/value pairs can be added to any given entry of\u000a        the data file and is considered part of the same entry until the\u000a        nextEntry() call is made.\u000a\u000a        e.g.::\u000a\u000a            #add some data for this trial\u000a            exp.addData('resp.rt', 0.8)\u000a            exp.addData('resp.key', 'k')\u000a            #end of trial - move to next line in data output\u000a            exp.nextEntry()\u000a        """\u000a        if name not in self.dataNames:\u000a            self.dataNames.append(name)\u000a        self.thisEntry[name]=value\u000a\u000a    def nextEntry(self):\u000a        """Calling nextEntry indicates to the ExperimentHandler that the\u000a        current trial has ended and so further\u000a        addData() calls correspond to the next trial.\u000a        """\u000a        this=self.thisEntry\u000a        #fetch data from each (potentially-nested) loop\u000a        for thisLoop in self.loopsUnfinished:\u000a            names, vals = self._getLoopInfo(thisLoop)\u000a            for n, name in enumerate(names):\u000a                this[name]=vals[n]\u000a        #add the extraInfo dict to the data\u000a        if type(self.extraInfo)==dict:\u000a            this.update(self.extraInfo)#NB update() really means mergeFrom()\u000a        self.entries.append(this)\u000a        #then create new empty entry for n\u000a        self.thisEntry = {}\u000a    def saveAsWideText(self, fileName, delim=None,\u000a                   matrixOnly=False,\u000a                   appendFile=False):\u000a        """Saves a long, wide-format text file, with one line representing the attributes and data\u000a        for a single trial. Suitable for analysis in R and SPSS.\u000a\u000a        If `appendFile=True` then the data will be added to the bottom of an existing file. Otherwise, if the file exists\u000a        already it will be overwritten\u000a\u000a        If `matrixOnly=True` then the file will not contain a header row, which can be handy if you want to append data\u000a        to an existing file of the same format.\u000a        """\u000a\u000a        #create the file or print to stdout\u000a        if appendFile: writeFormat='a'\u000a        else: writeFormat='w' #will overwrite a file\u000a        if os.path.exists(fileName) and writeFormat == 'w':\u000a            logging.warning('Data file, %s, will be overwritten' %fileName)\u000a\u000a        if fileName[-4:] in ['.csv', '.CSV']:\u000a            delim=','\u000a        else:\u000a            delim='\u005ct'\u000a\u000a        if fileName=='stdout':\u000a            f = sys.stdout\u000a        elif fileName[-4:] in ['.csv', '.CSV','.dlm','.DLM', '.tsv','.TSV']:\u000a            f= codecs.open(fileName,writeFormat, encoding = "utf-8")\u000a        else:\u000a            if delim==',':\u000a                f= codecs.open(fileName+'.csv',writeFormat, encoding = "utf-8")\u000a            else:\u000a                f=codecs.open(fileName+'.dlm',writeFormat, encoding = "utf-8")\u000a\u000a        names = self._getAllParamNames()\u000a        names.extend(self.dataNames)\u000a        names.extend(self._getExtraInfo()[0]) #names from the extraInfo dictionary\u000a        #write a header line\u000a        if not matrixOnly:\u000a            for heading in names:\u000a                f.write(u'%s%s' %(heading,delim))\u000a            f.write('\u005cn')\u000a        #write the data for each entry\u000a        for entry in self.entries:\u000a            for name in names:\u000a                if name in entry.keys():\u000a                    if ',' in unicode(entry[name]):\u000a                        f.write(u'"%s"%s' %(entry[name],delim))\u000a                    else:\u000a                        f.write(u'%s%s' %(entry[name],delim))\u000a                else:\u000a                    f.write(delim)\u000a            f.write('\u005cn')\u000a        f.close()\u000a        self.saveWideText=False\u000a    def saveAsPickle(self,fileName, fileCollisionMethod = 'rename'):\u000a        """Basically just saves a copy of self (with data) to a pickle file.\u000a\u000a        This can be reloaded if necessary and further analyses carried out.\u000a\u000a        :Parameters:\u000a\u000a            fileCollisionMethod: Collision method passed to ~psychopy.misc._handleFileCollision\u000a        """\u000a        #otherwise use default location\u000a        if not fileName.endswith('.psydat'):\u000a            fileName+='.psydat'\u000a        if os.path.exists(fileName):\u000a            fileName = misc._handleFileCollision(fileName, fileCollisionMethod)\u000a\u000a        #create the file or print to stdout\u000a        f = open(fileName, 'wb')\u000a        cPickle.dump(self, f)\u000a        f.close()\u000a        #no need to save again\u000a        self.savePickle=False\u000a\u000a    def abort(self):\u000a        """Inform the ExperimentHandler that the run was aborted.\u000a\u000a        Experiment handler will attempt automatically to save data (even in the event of a crash if possible).\u000a        So if you quit your script early you may want to tell the Handler not to save out the data files for this run.\u000a        This is the method that allows you to do that.\u000a        """\u000a        self.savePickle=False\u000a        self.saveWideText=False\u000a\u000aclass TrialType(dict):\u000a    """This is just like a dict, except that you can access keys with obj.key\u000a    """\u000a    def __getattribute__(self, name):\u000a        try:#to get attr from dict in normal way (passing self)\u000a            return dict.__getattribute__(self, name)\u000a        except AttributeError:\u000a            try:\u000a                return self[name]\u000a            except KeyError:\u000a                raise AttributeError, ('TrialType has no attribute (or key) \u005c'%s\u005c'' %(name))\u000a\u000aclass _BaseTrialHandler(object):\u000a    def setExp(self, exp):\u000a        """Sets the ExperimentHandler that this handler is attached to\u000a\u000a        Do NOT attempt to set the experiment using::\u000a\u000a            trials._exp = myExperiment\u000a\u000a        because it needs to be performed using the `weakref` module.\u000a        """\u000a        #need to use a weakref to avoid creating a circular reference that\u000a        #prevents effective object deletion\u000a        expId=id(exp)\u000a        _experiments[expId] = exp\u000a        self._exp = expId\u000a    def getExp(self):\u000a        """Return the ExperimentHandler that this handler is attached to, if any.\u000a        Returns None if not attached\u000a        """\u000a        if self._exp==None or self._exp not in _experiments:\u000a            return None\u000a        else:\u000a            return _experiments[self._exp]\u000a    def _terminate(self):\u000a        """Remove references to ourself in experiments and terminate the loop\u000a        """\u000a        #remove ourself from the list of unfinished loops in the experiment\u000a        exp=self.getExp()\u000a        if exp!=None:\u000a            exp.loopEnded(self)\u000a        #and halt the loop\u000a        raise StopIteration\u000a    def saveAsPickle(self,fileName, fileCollisionMethod = 'rename'):\u000a        """Basically just saves a copy of the handler (with data) to a pickle file.\u000a\u000a        This can be reloaded if necessesary and further analyses carried out.\u000a\u000a        :Parameters:\u000a\u000a            fileCollisionMethod: Collision method passed to ~psychopy.misc._handleFileCollision\u000a        """\u000a        if self.thisTrialN<1 and self.thisRepN<1:#if both are <1 we haven't started\u000a            logging.info('.saveAsPickle() called but no trials completed. Nothing saved')\u000a            return -1\u000a        #otherwise use default location\u000a        if not fileName.endswith('.psydat'):\u000a            fileName+='.psydat'\u000a        if os.path.exists(fileName):\u000a            fileName = misc._handleFileCollision(fileName, fileCollisionMethod)\u000a\u000a        #create the file or print to stdout\u000a        f = open(fileName, 'wb')\u000a        cPickle.dump(self, f)\u000a        f.close()\u000a    def saveAsText(self,fileName,\u000a                   stimOut=[],\u000a                   dataOut=('n','all_mean','all_std', 'all_raw'),\u000a                   delim=None,\u000a                   matrixOnly=False,\u000a                   appendFile=True,\u000a                   summarised=True,\u000a                   ):\u000a        """\u000a        Write a text file with the data and various chosen stimulus attributes\u000a\u000a         :Parameters:\u000a\u000a            fileName:\u000a                will have .dlm appended (so you can double-click it to\u000a                open in excel) and can include path info.\u000a\u000a            stimOut:\u000a                the stimulus attributes to be output. To use this you need to\u000a                use a list of dictionaries and give here the names of dictionary keys\u000a                that you want as strings\u000a\u000a            dataOut:\u000a                a list of strings specifying the dataType and the analysis to\u000a                be performed,in the form `dataType_analysis`. The data can be any of the types that\u000a                you added using trialHandler.data.add() and the analysis can be either\u000a                'raw' or most things in the numpy library, including;\u000a                'mean','std','median','max','min'...\u000a                The default values will output the raw, mean and std of all datatypes found\u000a\u000a            delim:\u000a                allows the user to use a delimiter other than tab ("," is popular with file extension ".csv")\u000a\u000a            matrixOnly:\u000a                outputs the data with no header row or extraInfo attached\u000a\u000a            appendFile:\u000a                will add this output to the end of the specified file if it already exists\u000a\u000a        """\u000a        if self.thisTrialN<1 and self.thisRepN<1:#if both are <1 we haven't started\u000a            logging.info('TrialHandler.saveAsText called but no trials completed. Nothing saved')\u000a            return -1\u000a\u000a        dataArray = self._createOutputArray(stimOut=[],\u000a            dataOut=dataOut,\u000a            matrixOnly=False,)\u000a\u000a        #set default delimiter if none given\u000a        if delim==None:\u000a            if fileName[-4:] in ['.csv','.CSV']:\u000a                delim=','\u000a            else:\u000a                delim='\u005ct'\u000a\u000a        #create the file or print to stdout\u000a        if appendFile: writeFormat='a'\u000a        else: writeFormat='w' #will overwrite a file\u000a        if fileName=='stdout':\u000a            f = sys.stdout\u000a        elif fileName[-4:] in ['.dlm','.DLM', '.csv', '.CSV']:\u000a            f= codecs.open(fileName,writeFormat, encoding = "utf-8")\u000a        else:\u000a            if delim==',':\u000a                f= codecs.open(fileName+'.csv',writeFormat, encoding = "utf-8")\u000a            else:\u000a                f=codecs.open(fileName+'.dlm',writeFormat, encoding = "utf-8")\u000a\u000a        #loop through lines in the data matrix\u000a        for line in dataArray:\u000a            for cellN, entry in enumerate(line):\u000a                if delim in unicode(entry):#surround in quotes to prevent effect of delimiter\u000a                    f.write(u'"%s"' %unicode(entry))\u000a                else:\u000a                    f.write(unicode(entry))\u000a                if cellN<(len(line)-1):\u000a                    f.write(delim)\u000a            f.write("\u005cn")#add an EOL at end of each line\u000a        if f != sys.stdout:\u000a            f.close()\u000a            logging.info('saved data to %s' %f.name)\u000a    def printAsText(self, stimOut=[],\u000a                    dataOut=('all_mean', 'all_std', 'all_raw'),\u000a                    delim='\u005ct',\u000a                    matrixOnly=False,\u000a                  ):\u000a        """Exactly like saveAsText() except that the output goes\u000a        to the screen instead of a file"""\u000a        self.saveAsText('stdout', stimOut, dataOut, delim, matrixOnly)\u000a\u000a    def saveAsExcel(self,fileName, sheetName='rawData',\u000a                    stimOut=[],\u000a                    dataOut=('n','all_mean','all_std', 'all_raw'),\u000a                    matrixOnly=False,\u000a                    appendFile=True,\u000a                    ):\u000a        """\u000a        Save a summary data file in Excel OpenXML format workbook (:term:`xlsx`) for processing\u000a        in most spreadsheet packages. This format is compatible with\u000a        versions of Excel (2007 or greater) and and with OpenOffice (>=3.0).\u000a\u000a        It has the advantage over the simpler text files (see :func:`TrialHandler.saveAsText()` )\u000a        that data can be stored in multiple named sheets within the file. So you could have a single file\u000a        named after your experiment and then have one worksheet for each participant. Or you could have\u000a        one file for each participant and then multiple sheets for repeated sessions etc.\u000a\u000a        The file extension `.xlsx` will be added if not given already.\u000a\u000a        :Parameters:\u000a\u000a            fileName: string\u000a                the name of the file to create or append. Can include relative or absolute path\u000a\u000a            sheetName: string\u000a                the name of the worksheet within the file\u000a\u000a            stimOut: list of strings\u000a                the attributes of the trial characteristics to be output. To use this you need to have provided\u000a                a list of dictionaries specifying to trialList parameter of the TrialHandler\u000a                and give here the names of strings specifying entries in that dictionary\u000a\u000a            dataOut: list of strings\u000a                specifying the dataType and the analysis to\u000a                be performed, in the form `dataType_analysis`. The data can be any of the types that\u000a                you added using trialHandler.data.add() and the analysis can be either\u000a                'raw' or most things in the numpy library, including\u000a                'mean','std','median','max','min'. e.g. `rt_max` will give a column of max reaction\u000a                times across the trials assuming that `rt` values have been stored.\u000a                The default values will output the raw, mean and std of all datatypes found\u000a\u000a            appendFile: True or False\u000a                If False any existing file with this name will be overwritten. If True then a new worksheet will be appended.\u000a                If a worksheet already exists with that name a number will be added to make it unique.\u000a\u000a\u000a        """\u000a\u000a        if self.thisTrialN<1 and self.thisRepN<1:#if both are <1 we haven't started\u000a            logging.info('TrialHandler.saveAsExcel called but no trials completed. Nothing saved')\u000a            return -1\u000a\u000a        #NB this was based on the limited documentation (1 page wiki) for openpyxl v1.0\u000a        if not haveOpenpyxl:\u000a            raise ImportError, 'openpyxl is required for saving files in Excel (xlsx) format, but was not found.'\u000a            return -1\u000a\u000a        #create the data array to be sent to the Excel file\u000a        dataArray = self._createOutputArray(stimOut=[],\u000a            dataOut=dataOut,\u000a            matrixOnly=False,)\u000a\u000a        #import necessary subpackages - they are small so won't matter to do it here\u000a        from openpyxl.workbook import Workbook\u000a        from openpyxl.writer.excel import ExcelWriter\u000a        from openpyxl.reader.excel import load_workbook\u000a\u000a        if not fileName.endswith('.xlsx'): fileName+='.xlsx'\u000a        #create or load the file\u000a        if appendFile and os.path.isfile(fileName):\u000a            wb = load_workbook(fileName)\u000a            newWorkbook=False\u000a        else:\u000a            if not appendFile: #the file exists but we're not appending, so will be overwritten\u000a                logging.warning('Data file, %s, will be overwritten' %fileName)\u000a            wb = Workbook()#create new workbook\u000a            wb.properties.creator='PsychoPy'+psychopy.__version__\u000a            newWorkbook=True\u000a\u000a        ew = ExcelWriter(workbook = wb)\u000a\u000a        if newWorkbook:\u000a            ws = wb.worksheets[0]\u000a            ws.title=sheetName\u000a        else:\u000a            ws=wb.create_sheet()\u000a            ws.title=sheetName\u000a\u000a        #loop through lines in the data matrix\u000a        for lineN, line in enumerate(dataArray):\u000a            if line==None:\u000a                continue\u000a            for colN, entry in enumerate(line):\u000a                if entry in [None]:\u000a                    entry=''\u000a                try:\u000a                    ws.cell(_getExcelCellName(col=colN,row=lineN)).value = float(entry)#if it can conver to a number (from numpy) then do it\u000a                except:\u000a                    ws.cell(_getExcelCellName(col=colN,row=lineN)).value = unicode(entry)#else treat as unicode\u000a\u000a        ew.save(filename = fileName)\u000a\u000a    def nextTrial(self):\u000a        """DEPRECATION WARNING: nextTrial() will be deprecated\u000a        please use next() instead.\u000a        jwp: 19/6/06\u000a        """\u000a        if self._warnUseOfNext:\u000a            logging.warning("""DEPRECATION WARNING: nextTrial() will be deprecated\u000a        please use next() instead.\u000a        jwp: 19/6/06\u000a        """)\u000a            self._warnUseOfNext=False\u000a        return self.next()\u000a    def getOriginPathAndFile(self, originPath=None):\u000a        """Attempts to determine the path of the script that created this data file\u000a        and returns both the path to that script and it's contents.\u000a        Useful to store the entire experiment with the data.\u000a\u000a        If originPath is provided (e.g. from Builder) then this is used otherwise\u000a        the calling script is the originPath (fine from a standard python script).\u000a        """\u000a        #self.originPath and self.origin (the contents of the origin file)\u000a        if originPath==None or not os.path.isfile(originPath):\u000a            try:\u000a                originPath = inspect.getouterframes(inspect.currentframe())[1][1]\u000a                logging.debug("Using %s as origin file" %originPath)\u000a            except:\u000a                logging.debug("Failed to find origin file using inspect.getouterframes")\u000a                return '',''\u000a        if os.path.isfile(originPath):#do we NOW have a path?\u000a            origin = codecs.open(originPath,"r", encoding = "utf-8").read()\u000a        else:\u000a            origin=None\u000a        return originPath, origin\u000a\u000aclass TrialHandler(_BaseTrialHandler):\u000a    """Class to handle trial sequencing and data storage.\u000a\u000a    Calls to .next() will fetch the next trial object given to this handler,\u000a    according to the method specified (random, sequential, fullRandom). Calls\u000a    will raise a StopIteration error if trials have finished.\u000a\u000a    See demo_trialHandler.py\u000a\u000a    The psydat file format is literally just a pickled copy of the TrialHandler object that\u000a    saved it. You can open it with::\u000a\u000a            from psychopy import misc\u000a            dat = misc.fromFile(path)\u000a\u000a    Then you'll find that `dat` has the following attributes that\u000a    """\u000a    def __init__(self,\u000a                 trialList,\u000a                 nReps,\u000a                 method='random',\u000a                 dataTypes=None,\u000a                 extraInfo=None,\u000a                 seed=None,\u000a                 originPath=None,\u000a                 name=''):\u000a        """\u000a\u000a        :Parameters:\u000a\u000a            trialList: a simple list (or flat array) of dictionaries specifying conditions\u000a                This can be imported from an excel/csv file using :func:`~psychopy.data.importConditions`\u000a\u000a            nReps: number of repeats for all conditions\u000a\u000a            method: *'random',* 'sequential', or 'fullRandom'\u000a                'sequential' obviously presents the conditions in the order they appear in the list.\u000a                'random' will result in a shuffle of the conditions on each repeat, but all conditions\u000a                occur once before the second repeat etc. 'fullRandom' fully randomises the\u000a                trials across repeats as well, which means you could potentially run all trials of\u000a                one condition before any trial of another.\u000a\u000a            dataTypes: (optional) list of names for data storage. e.g. ['corr','rt','resp']\u000a                If not provided then these will be created as needed during calls to\u000a                :func:`~psychopy.data.TrialHandler.addData`\u000a\u000a            extraInfo: A dictionary\u000a                This will be stored alongside the data and usually describes the experiment and\u000a                subject ID, date etc.\u000a\u000a            seed: an integer\u000a                If provided then this fixes the random number generator to use the same pattern\u000a                of trials, by seeding its startpoint\u000a\u000a            originPath: a string describing the location of the script/experiment file path\u000a                The psydat file format will store a copy of the experiment if possible. If no file path\u000a                is provided here then the TrialHandler will still store a copy of the script where it was\u000a                created\u000a\u000a        :Attributes (after creation):\u000a\u000a            .data - a dictionary of numpy arrays, one for each data type stored\u000a\u000a            .trialList - the original list of dicts, specifying the conditions\u000a\u000a            .thisIndex - the index of the current trial in the original conditions list\u000a\u000a            .nTotal - the total number of trials that will be run\u000a\u000a            .nRemaining - the total number of trials remaining\u000a\u000a            .thisN - total trials completed so far\u000a\u000a            .thisRepN - which repeat you are currently on\u000a\u000a            .thisTrialN - which trial number *within* that repeat\u000a\u000a            .thisTrial - a dictionary giving the parameters of the current trial\u000a\u000a            .finished - True/False for have we finished yet\u000a\u000a            .extraInfo - the dictionary of extra info as given at beginning\u000a\u000a            .origin - the contents of the script or builder experiment that created the handler\u000a\u000a        """\u000a        self.name=name\u000a        if trialList in [None, []]:#user wants an empty trialList\u000a            self.trialList = [None]#which corresponds to a list with a single empty entry\u000a        else:\u000a            self.trialList =trialList\u000a        #convert any entry in the TrialList into a TrialType object (with obj.key or obj[key] access)\u000a        for n, entry in enumerate(trialList):\u000a            if type(entry)==dict:\u000a                trialList[n]=TrialType(entry)\u000a        self.nReps = int(nReps)\u000a        self.nTotal = self.nReps*len(self.trialList)\u000a        self.nRemaining =self.nTotal #subtract 1 each trial\u000a        self.method = method\u000a        self.thisRepN = 0        #records which repetition or pass we are on\u000a        self.thisTrialN = -1    #records which trial number within this repetition\u000a        self.thisN = -1\u000a        self.thisIndex = 0        #the index of the current trial in the conditions list\u000a        self.thisTrial = []\u000a        self.finished=False\u000a        self.extraInfo=extraInfo\u000a        self._warnUseOfNext=True\u000a        self.seed=seed\u000a        #create dataHandler\u000a        self.data = DataHandler(trials=self)\u000a        if dataTypes!=None:\u000a            self.data.addDataType(dataTypes)\u000a        self.data.addDataType('ran')\u000a        self.data['ran'].mask=False#this is a bool - all entries are valid\u000a        self.data.addDataType('order')\u000a        #generate stimulus sequence\u000a        if self.method in ['random','sequential', 'fullRandom']:\u000a            self.sequenceIndices = self._createSequence()\u000a        else: self.sequenceIndices=[]\u000a\u000a        self.originPath, self.origin = self.getOriginPathAndFile(originPath)\u000a        self._exp = None#the experiment handler that owns me!\u000a\u000a    def __iter__(self):\u000a        return self\u000a    def __repr__(self):\u000a        """prints a more verbose version of self as string"""\u000a        return self.__str__(verbose=True)\u000a\u000a    def __str__(self, verbose=False):\u000a        """string representation of the object"""\u000a        strRepres = 'psychopy.data.TrialHandler(\u005cn'\u000a        attribs = dir(self)\u000a\u000a        #print data first, then all others\u000a        try: data=self.data\u000a        except: data=None\u000a        if data:\u000a            strRepres += str('\u005ctdata=')\u000a            strRepres +=str(data)+'\u005cn'\u000a\u000a        for thisAttrib in attribs:\u000a            #can handle each attribute differently\u000a            if 'instancemethod' in str(type(getattr(self,thisAttrib))):\u000a                #this is a method\u000a                continue\u000a            elif thisAttrib[0]=='_':\u000a                #the attrib is private\u000a                continue\u000a            elif thisAttrib=='data':\u000a                #we handled this first\u000a                continue\u000a            elif len(str(getattr(self,thisAttrib)))>20 and \u005c\u000a                 not verbose:\u000a                #just give type of LONG public attribute\u000a                strRepres += str('\u005ct'+thisAttrib+'=')\u000a                strRepres += str(type(getattr(self,thisAttrib)))+'\u005cn'\u000a            else:\u000a                #give the complete contents of attribute\u000a                strRepres += str('\u005ct'+thisAttrib+'=')\u000a                strRepres += str(getattr(self,thisAttrib))+'\u005cn'\u000a\u000a        strRepres+=')'\u000a        return strRepres\u000a\u000a    def _createSequence(self):\u000a        """\u000a        Pre-generates the sequence of trial presentations (for non-adaptive methods).\u000a        This is called automatically when the TrialHandler is initialised so doesn't\u000a        need an explicit call from the user.\u000a\u000a        The returned sequence has form indices[stimN][repN]\u000a        Example: sequential with 6 trialtypes (rows), 5 reps (cols), returns:\u000a            [[0 0 0 0 0]\u000a             [1 1 1 1 1]\u000a             [2 2 2 2 2]\u000a             [3 3 3 3 3]\u000a             [4 4 4 4 4]\u000a             [5 5 5 5 5]]\u000a        These 30 trials will be returned by .next() in the order:\u000a            0, 1, 2, 3, 4, 5,   0, 1, 2, ...  ... 3, 4, 5\u000a\u000a        To add a new type of sequence (as of v1.65.02):\u000a        - add the sequence generation code here\u000a        - adjust "if self.method in [ ...]:" in both __init__ and .next()\u000a        - adjust allowedVals in experiment.py -> shows up in DlgLoopProperties\u000a        Note that users can make any sequence whatsoever outside of PsychoPy, and\u000a        specify sequential order; any order is possible this way.\u000a        """\u000a        # create indices for a single rep\u000a        indices = numpy.asarray(self._makeIndices(self.trialList), dtype=int)\u000a\u000a        if self.method == 'random':\u000a            sequenceIndices = []\u000a            seed=self.seed\u000a            for thisRep in range(self.nReps):\u000a                thisRepSeq = misc.shuffleArray(indices.flat, seed=seed).tolist()\u000a                seed=None#so that we only seed the first pass through!\u000a                sequenceIndices.append(thisRepSeq)\u000a            sequenceIndices = numpy.transpose(sequenceIndices)\u000a        elif self.method == 'sequential':\u000a            sequenceIndices = numpy.repeat(indices,self.nReps,1)\u000a        elif self.method == 'fullRandom':\u000a            # indices*nReps, flatten, shuffle, unflatten; only use seed once\u000a            sequential = numpy.repeat(indices, self.nReps,1) # = sequential\u000a            randomFlat = misc.shuffleArray(sequential.flat, seed=self.seed)\u000a            sequenceIndices = numpy.reshape(randomFlat, (len(indices), self.nReps))\u000a        logging.exp('Created sequence: %s, trialTypes=%d, nReps=%i, seed=%s' %\u000a                (self.method, len(indices), self.nReps, str(self.seed) )  )\u000a        return sequenceIndices\u000a\u000a    def _makeIndices(self,inputArray):\u000a        """\u000a        Creates an array of tuples the same shape as the input array\u000a        where each tuple contains the indices to itself in the array.\u000a\u000a        Useful for shuffling and then using as a reference.\u000a        """\u000a        inputArray  = numpy.asarray(inputArray, 'O')#make sure its an array of objects (can be strings etc)\u000a        #get some simple variables for later\u000a        dims=inputArray.shape\u000a        dimsProd=numpy.product(dims)\u000a        dimsN = len(dims)\u000a        dimsList = range(dimsN)\u000a        listOfLists = []\u000a        arrayOfTuples = numpy.ones(dimsProd, 'O')#this creates space for an array of any objects\u000a\u000a        #for each dimension create list of its indices (using modulo)\u000a        for thisDim in dimsList:\u000a            prevDimsProd = numpy.product(dims[:thisDim])\u000a            thisDimVals = numpy.arange(dimsProd)/prevDimsProd % dims[thisDim] #NB this means modulus in python\u000a            listOfLists.append(thisDimVals)\u000a\u000a        #convert to array\u000a        indexArr = numpy.asarray(listOfLists)\u000a        for n in range(dimsProd):\u000a            arrayOfTuples[n] = tuple((indexArr[:,n]))\u000a        return (numpy.reshape(arrayOfTuples,dims)).tolist()\u000a\u000a    def next(self):\u000a        """Advances to next trial and returns it.\u000a        Updates attributes; thisTrial, thisTrialN and thisIndex\u000a        If the trials have ended this method will raise a StopIteration error.\u000a        This can be handled with code such as::\u000a\u000a            trials = TrialHandler(.......)\u000a            for eachTrial in trials:#automatically stops when done\u000a                #do stuff\u000a\u000a        or::\u000a\u000a            trials = TrialHandler(.......)\u000a            while True: #ie forever\u000a                try:\u000a                    thisTrial = trials.next()\u000a                except StopIteration:#we got a StopIteration error\u000a                    break #break out of the forever loop\u000a                #do stuff here for the trial\u000a        """\u000a        #update pointer for next trials\u000a        self.thisTrialN+=1#number of trial this pass\u000a        self.thisN+=1 #number of trial in total\u000a        self.nRemaining-=1\u000a        if self.thisTrialN==len(self.trialList):\u000a            #start a new repetition\u000a            self.thisTrialN=0\u000a            self.thisRepN+=1\u000a        if self.thisRepN>=self.nReps:\u000a            #all reps complete\u000a            self.thisTrial=[]\u000a            self.finished=True\u000a\u000a        if self.finished==True:\u000a            self._terminate()\u000a\u000a        #fetch the trial info\u000a        if self.method in ['random','sequential','fullRandom']:\u000a            self.thisIndex = self.sequenceIndices[self.thisTrialN][self.thisRepN]\u000a            self.thisTrial = self.trialList[self.thisIndex]\u000a            self.data.add('ran',1)\u000a            self.data.add('order',self.thisN)\u000a        logging.exp('New trial (rep=%i, index=%i): %s' %(self.thisRepN, self.thisTrialN, self.thisTrial), obj=self.thisTrial)\u000a        return self.thisTrial\u000a\u000a    def getFutureTrial(self, n=1):\u000a        """Returns the condition for n trials into the future without advancing\u000a        the trials.\u000a        """\u000a        if n>self.nRemaining:\u000a            return None\u000a        seqs = numpy.array(self.sequenceIndices).transpose().flat\u000a        condIndex=seqs[self.thisN+n]\u000a        return self.trialList[condIndex]\u000a\u000a    def _createOutputArray(self,stimOut,dataOut,delim=None,\u000a                          matrixOnly=False):\u000a        """\u000a        Does the leg-work for saveAsText and saveAsExcel.\u000a        Combines stimOut with ._parseDataOutput()\u000a        """\u000a        if stimOut==[] and len(self.trialList) and hasattr(self.trialList[0],'keys'):\u000a            stimOut=self.trialList[0].keys()\u000a            #these get added somewhere (by DataHandler?)\u000a            if 'n' in stimOut:\u000a                stimOut.remove('n')\u000a            if 'float' in stimOut:\u000a                stimOut.remove('float')\u000a\u000a        lines=[]\u000a        #parse the dataout section of the output\u000a        dataOut, dataAnal, dataHead = self._createOutputArrayData(dataOut=dataOut)\u000a        if not matrixOnly:\u000a            thisLine=[]\u000a            lines.append(thisLine)\u000a            #write a header line\u000a            for heading in stimOut+dataHead:\u000a                if heading=='ran_sum': heading ='n'\u000a                elif heading=='order_raw': heading ='order'\u000a                thisLine.append(heading)\u000a\u000a        #loop through stimuli, writing data\u000a        for stimN in range(len(self.trialList)):\u000a            thisLine=[]\u000a            lines.append(thisLine)\u000a            #first the params for this stim (from self.trialList)\u000a            for heading in stimOut:\u000a                thisLine.append(self.trialList[stimN][heading])\u000a\u000a            #then the data for this stim (from self.data)\u000a            for thisDataOut in dataOut:\u000a                #make a string version of the data and then format it\u000a                tmpData = dataAnal[thisDataOut][stimN]\u000a                if hasattr(tmpData,'tolist'): #is a numpy array\u000a                    strVersion = unicode(tmpData.tolist())\u000a                    #for numeric data replace None with a blank cell\u000a                    if tmpData.dtype.kind not in ['SaUV']:\u000a                        strVersion=strVersion.replace('None','')\u000a                elif tmpData in [None,'None']:\u000a                    strVersion=''\u000a                else:\u000a                    strVersion = unicode(tmpData)\u000a\u000a                if strVersion=='()':\u000a                    strVersion="--"# 'no data' in masked array should show as "--"\u000a                #handle list of values (e.g. rt_raw )\u000a                if len(strVersion) and strVersion[0] in ["[", "("] and strVersion[-1] in ["]", ")"]:\u000a                    strVersion=strVersion[1:-1]#skip first and last chars\u000a                #handle lists of lists (e.g. raw of multiple key presses)\u000a                if len(strVersion) and strVersion[0] in ["[", "("] and strVersion[-1] in ["]", ")"]:\u000a                    tup = eval(strVersion) #convert back to a tuple\u000a                    for entry in tup:\u000a                        #contents of each entry is a list or tuple so keep in quotes to avoid probs with delim\u000a                        thisLine.append(unicode(entry))\u000a                else:\u000a                    thisLine.extend(strVersion.split(','))\u000a\u000a        #add self.extraInfo\u000a        if (self.extraInfo != None) and not matrixOnly:\u000a            lines.append([])\u000a            lines.append(['extraInfo'])#give a single line of space and then a heading\u000a            for key, value in self.extraInfo.items():\u000a                lines.append([key,value])\u000a        return lines\u000a\u000a    def _createOutputArrayData(self, dataOut):\u000a        """This just creates the dataOut part of the output matrix.\u000a        It is called by _createOutputArray() which creates the header line and adds the stimOut columns\u000a        """\u000a        dataHead=[]#will store list of data headers\u000a        dataAnal=dict([])    #will store data that has been analyzed\u000a        if type(dataOut)==str: dataOut=[dataOut]#don't do list convert or we get a list of letters\u000a        elif type(dataOut)!=list: dataOut = list(dataOut)\u000a\u000a        #expand any 'all' dataTypes to be the full list of available dataTypes\u000a        allDataTypes=self.data.keys()\u000a        #treat these separately later\u000a        allDataTypes.remove('ran')\u000a        #ready to go trhough standard data types\u000a        dataOutNew=[]\u000a        for thisDataOut in dataOut:\u000a            if thisDataOut=='n':\u000a                #n is really just the sum of the ran trials\u000a                dataOutNew.append('ran_sum')\u000a                continue#no need to do more with this one\u000a            #then break into dataType and analysis\u000a            dataType, analType =string.rsplit(thisDataOut, '_', 1)\u000a            if dataType=='all':\u000a                dataOutNew.extend([key+"_"+analType for key in allDataTypes])\u000a                if 'order_mean' in dataOutNew: dataOutNew.remove('order_mean')\u000a                if 'order_std' in dataOutNew: dataOutNew.remove('order_std')\u000a            else:\u000a                dataOutNew.append(thisDataOut)\u000a        dataOut=dataOutNew\u000a        dataOut.sort()#so that all datatypes come together, rather than all analtypes\u000a\u000a        #do the various analyses, keeping track of fails (e.g. mean of a string)\u000a        dataOutInvalid=[]\u000a        #add back special data types (n and order)\u000a        if 'ran_sum' in dataOut:#move n to the first column\u000a            dataOut.remove('ran_sum')\u000a            dataOut.insert(0,'ran_sum')\u000a        if 'order_raw' in dataOut:#move order_raw to the second column\u000a            dataOut.remove('order_raw')\u000a            dataOut.append('order_raw')\u000a        #do the necessary analysis on the data\u000a        for thisDataOutN,thisDataOut in enumerate(dataOut):\u000a            dataType, analType =string.rsplit(thisDataOut, '_', 1)\u000a            if not self.data.has_key(dataType):\u000a                dataOutInvalid.append(thisDataOut)#that analysis can't be done\u000a                continue\u000a            thisData = self.data[dataType]\u000a\u000a            #set the header\u000a            dataHead.append(dataType+'_'+analType)\u000a            #analyse thisData using numpy module\u000a            if analType in dir(numpy):\u000a                try:#this will fail if we try to take mean of a string for example\u000a                    if analType=='std':\u000a                        thisAnal = numpy.std(thisData,axis=1,ddof=0)\u000a                        #normalise by N-1 instead. his should work by setting ddof=1\u000a                        #but doesn't as of 08/2010 (because of using a masked array?)\u000a                        N=thisData.shape[1]\u000a                        if N == 1:\u000a                            thisAnal*=0 #prevent a divide-by-zero error\u000a                        else:\u000a                            thisAnal = thisAnal*numpy.sqrt(N)/numpy.sqrt(N-1)\u000a                    else:\u000a                        exec("thisAnal = numpy.%s(thisData,1)" %analType)\u000a                except:\u000a                    dataHead.remove(dataType+'_'+analType)#that analysis doesn't work\u000a                    dataOutInvalid.append(thisDataOut)\u000a                    continue#to next analysis\u000a            elif analType=='raw':\u000a                thisAnal=thisData\u000a            else:\u000a                raise AttributeError, 'You can only use analyses from numpy'\u000a            #add extra cols to header if necess\u000a            if len(thisAnal.shape)>1:\u000a                for n in range(thisAnal.shape[1]-1):\u000a                    dataHead.append("")\u000a            dataAnal[thisDataOut]=thisAnal\u000a\u000a        #remove invalid analyses (e.g. average of a string)\u000a        for invalidAnal in dataOutInvalid: dataOut.remove(invalidAnal)\u000a        return dataOut, dataAnal, dataHead\u000a\u000a\u000a    def saveAsWideText(self,fileName,\u000a                   delim='\u005ct',\u000a                   matrixOnly=False,\u000a                   appendFile=True,\u000a                  ):\u000a        """\u000a        Write a text file with the session, stimulus, and data values from each trial in chronological order.\u000a\u000a        That is, unlike 'saveAsText' and 'saveAsExcel':\u000a         - each row comprises information from only a single trial.\u000a         - no summarising is done (such as collapsing to produce mean and standard deviation values across trials).\u000a\u000a        This 'wide' format, as expected by R for creating dataframes, and various other analysis programs, means that some\u000a        information must be repeated on every row.\u000a\u000a        In particular, if the trialHandler's 'extraInfo' exists, then each entry in there occurs in every row.\u000a        In builder, this will include any entries in the 'Experiment info' field of the 'Experiment settings' dialog.\u000a        In Coder, this information can be set using something like:\u000a            myTrialHandler.extraInfo = {'SubjID':'Joan Smith', 'DOB':1970 Nov 16, 'Group':'Control'}\u000a\u000a         :Parameters:\u000a\u000a            fileName:\u000a                if extension is not specified, '.csv' will be appended if the delimiter is ',', else '.txt' will be appended.\u000a                Can include path info.\u000a\u000a            delim:\u000a                allows the user to use a delimiter other than the default tab ("," is popular with file extension ".csv")\u000a\u000a            matrixOnly:\u000a                outputs the data with no header row.\u000a\u000a            appendFile:\u000a                will add this output to the end of the specified file if it already exists.\u000a\u000a        """\u000a        if self.thisTrialN<1 and self.thisRepN<1:#if both are <1 we haven't started\u000a            logging.info('TrialHandler.saveAsWideText called but no trials completed. Nothing saved')\u000a            return -1\u000a\u000a        #create the file or print to stdout\u000a        if appendFile:\u000a            writeFormat='a'\u000a        else: writeFormat='w' #will overwrite a file\u000a        if fileName=='stdout':\u000a            f = sys.stdout\u000a        elif fileName[-4:] in ['.dlm','.DLM', '.tsv', '.TSV', '.txt', '.TXT', '.csv', '.CSV']:\u000a            f = codecs.open(fileName,writeFormat, encoding = "utf-8")\u000a        else:\u000a            if delim==',': f = codecs.open(fileName+'.csv', writeFormat, encoding="utf-8")\u000a            else: f=codecs.open(fileName+'.txt',writeFormat, encoding = "utf-8")\u000a\u000a        # collect parameter names related to the stimuli:\u000a        if self.trialList[0]:\u000a            header = self.trialList[0].keys()\u000a        else:\u000a            header = []\u000a        # and then add parameter names related to data (e.g. RT)\u000a        header.extend(self.data.dataTypes)\u000a\u000a        # loop through each trial, gathering the actual values:\u000a        dataOut = []\u000a        trialCount = 0\u000a        # total number of trials = number of trialtypes * number of repetitions:\u000a\u000a        repsPerType={}\u000a        for rep in range(self.nReps):\u000a            for trialN in range(len(self.trialList)):\u000a                #find out what trial type was on this trial\u000a                trialTypeIndex = self.sequenceIndices[trialN, rep]\u000a                #determine which repeat it is for this trial\u000a                if trialTypeIndex not in repsPerType.keys():\u000a                    repsPerType[trialTypeIndex]=0\u000a                else:\u000a                    repsPerType[trialTypeIndex]+=1\u000a                repThisType=repsPerType[trialTypeIndex]#what repeat are we on for this trial type?\u000a\u000a                # create a dictionary representing each trial:\u000a                # this is wide format, so we want fixed information (e.g. subject ID, date, etc) repeated every line if it exists:\u000a                if (self.extraInfo != None):\u000a                    nextEntry = self.extraInfo.copy()\u000a                else:\u000a                    nextEntry = {}\u000a\u000a                # add a trial number so the original order of the data can always be recovered if sorted during analysis:\u000a                trialCount += 1\u000a                nextEntry["TrialNumber"] = trialCount\u000a\u000a                # now collect the value from each trial of the variables named in the header:\u000a                for parameterName in header:\u000a                    # the header includes both trial and data variables, so need to check before accessing:\u000a                    if self.trialList[trialTypeIndex] and self.trialList[trialTypeIndex].has_key(parameterName):\u000a                        nextEntry[parameterName] = self.trialList[trialTypeIndex][parameterName]\u000a                    elif self.data.has_key(parameterName):\u000a                        nextEntry[parameterName] = self.data[parameterName][trialTypeIndex][repThisType]\u000a                    else: # allow a null value if this parameter wasn't explicitly stored on this trial:\u000a                        nextEntry[parameterName] = ''\u000a\u000a                #store this trial's data\u000a                dataOut.append(nextEntry)\u000a\u000a        # get the extra 'wide' parameter names into the header line:\u000a        header.insert(0,"TrialNumber")\u000a        if (self.extraInfo != None):\u000a            for key in self.extraInfo:\u000a                header.insert(0, key)\u000a\u000a        if not matrixOnly:\u000a        # write the header row:\u000a            nextLine = ''\u000a            for parameterName in header:\u000a                nextLine = nextLine + parameterName + delim\u000a            f.write(nextLine[:-1] + '\u005cn') # remove the final orphaned tab character\u000a\u000a        # write the data matrix:\u000a        for trial in dataOut:\u000a            nextLine = ''\u000a            for parameterName in header:\u000a                nextLine = nextLine + unicode(trial[parameterName]) + delim\u000a            nextLine = nextLine[:-1] # remove the final orphaned tab character\u000a            f.write(nextLine + '\u005cn')\u000a\u000a        if f != sys.stdout:\u000a            f.close()\u000a            logging.info('saved wide-format data to %s' %f.name)\u000a\u000a    def addData(self, thisType, value, position=None):\u000a        """Add data for the current trial\u000a        """\u000a        self.data.add(thisType, value, position=None)\u000a        if self.getExp()!=None:#update the experiment handler too\u000a            self.getExp().addData(thisType, value)\u000a\u000a\u000adef importTrialTypes(fileName, returnFieldNames=False):\u000a    """importTrialTypes is DEPRECATED (as of v1.70.00)\u000a    Please use `importConditions` for identical functionality.\u000a    """\u000a    logging.warning("importTrialTypes is DEPRECATED (as of v1.70.00). Please use `importConditions` for identical functionality.")\u000a    return importConditions(fileName, returnFieldNames)\u000a\u000adef importConditions(fileName, returnFieldNames=False):\u000a    """Imports a list of conditions from an .xlsx, .csv, or .pkl file\u000a\u000a    The output is suitable as an input to :class:`TrialHandler` `trialTypes` or to\u000a    :class:`MultiStairHandler` as a `conditions` list.\u000a\u000a    If `fileName` ends with:\u000a        - .csv:  import as a comma-separated-value file (header + row x col)\u000a        - .xlsx: import as Excel 2007 (xlsx) files. Sorry no support for older (.xls) is planned.\u000a        - .pkl:  import from a pickle file as list of lists (header + row x col)\u000a\u000a    The file should contain one row per type of trial needed and one column\u000a    for each parameter that defines the trial type. The first row should give\u000a    parameter names, which should:\u000a\u000a        - be unique\u000a        - begin with a letter (upper or lower case)\u000a        - contain no spaces or other punctuation (underscores are permitted)\u000a\u000a    """\u000a    def _assertValidVarNames(fieldNames, fileName):\u000a        """screens a list of names as candidate variable names. if all names are\u000a        OK, return silently; else raise ImportError with msg\u000a        """\u000a        if not all(fieldNames):\u000a            raise ImportError, 'Conditions file %s: Missing parameter name(s); empty cell(s) in the first row?' % fileName\u000a        for name in fieldNames:\u000a            OK, msg = isValidVariableName(name)\u000a            if not OK: #tailor message to importConditions\u000a                msg = msg.replace('Variables', 'Parameters (column headers)')\u000a                raise ImportError, 'Conditions file %s: %s%s"%s"' %(fileName, msg, os.linesep*2, name)\u000a\u000a    if fileName in ['None','none',None]:\u000a        if returnFieldNames:\u000a            return [], []\u000a        return []\u000a    if not os.path.isfile(fileName):\u000a        raise ImportError, 'Conditions file not found: %s' %os.path.abspath(fileName)\u000a\u000a    if fileName.endswith('.csv'):\u000a        #use csv import library to fetch the fieldNames\u000a        f = open(fileName, 'rU')#the U converts line endings to os.linesep (not unicode!)\u000a        #lines = f.read().split(os.linesep)#csv module is temperamental with line endings\u000a        try:\u000a            reader = csv.reader(f)#.split(os.linesep))\u000a        except:\u000a            raise ImportError, 'Could not open %s as conditions' % fileName\u000a        fieldNames = reader.next() # first row\u000a        _assertValidVarNames(fieldNames, fileName)\u000a        #use matplotlib to import data and intelligently check for data types\u000a        #all data in one column will be given a single type (e.g. if one cell is string, all will be set to string)\u000a        trialsArr = mlab.csv2rec(f) # data = non-header row x col\u000a        f.close()\u000a        #convert the record array into a list of dicts\u000a        trialList = []\u000a        for trialN, trialType in enumerate(trialsArr):\u000a            thisTrial ={}\u000a            for fieldN, fieldName in enumerate(fieldNames):\u000a                val = trialsArr[trialN][fieldN]\u000a                if type(val)==numpy.string_:\u000a                    val = unicode(val.decode('utf-8'))\u000a                    #if it looks like a list, convert it:\u000a                    if val.startswith('[') and val.endswith(']'):\u000a                        #exec('val=%s' %unicode(val.decode('utf8')))\u000a                        val = eval(val)\u000a                thisTrial[fieldName] = val\u000a            trialList.append(thisTrial)\u000a    elif fileName.endswith('.pkl'):\u000a        f = open(fileName, 'rU') # is U needed?\u000a        try:\u000a            trialsArr = cPickle.load(f)\u000a        except:\u000a            raise ImportError, 'Could not open %s as conditions' % fileName\u000a        f.close()\u000a        trialList = []\u000a        fieldNames = trialsArr[0] # header line first\u000a        _assertValidVarNames(fieldNames, fileName)\u000a        for row in trialsArr[1:]:\u000a            thisTrial = {}\u000a            for fieldN, fieldName in enumerate(fieldNames):\u000a                thisTrial[fieldName] = row[fieldN] # type is correct, being .pkl\u000a            trialList.append(thisTrial)\u000a    else:\u000a        if not haveOpenpyxl:\u000a            raise ImportError, 'openpyxl is required for loading excel format files, but it was not found.'\u000a        try:\u000a            wb = load_workbook(filename = fileName)\u000a        except: # InvalidFileException(unicode(e)): # this fails\u000a            raise ImportError, 'Could not open %s as conditions' % fileName\u000a        ws = wb.worksheets[0]\u000a        nCols = ws.get_highest_column()\u000a        nRows = ws.get_highest_row()\u000a\u000a        #get parameter names from the first row header\u000a        fieldNames = []\u000a        for colN in range(nCols):\u000a            fieldName = ws.cell(_getExcelCellName(col=colN, row=0)).value\u000a            fieldNames.append(fieldName)\u000a        _assertValidVarNames(fieldNames, fileName)\u000a\u000a        #loop trialTypes\u000a        trialList = []\u000a        for rowN in range(1, nRows):#skip header first row\u000a            thisTrial={}\u000a            for colN in range(nCols):\u000a                val = ws.cell(_getExcelCellName(col=colN, row=rowN)).value\u000a                #if it looks like a list, convert it\u000a                if type(val) in [unicode, str] and (\u000a                        val.startswith('[') and val.endswith(']') or\u000a                        val.startswith('(') and val.endswith(')') ):\u000a                    val = eval(val)\u000a                fieldName = fieldNames[colN]\u000a                thisTrial[fieldName] = val\u000a            trialList.append(thisTrial)\u000a\u000a    logging.exp('Imported %s as conditions, %d conditions, %d params' %\u000a                 (fileName, len(trialList), len(fieldNames)))\u000a    if returnFieldNames:\u000a        return (trialList,fieldNames)\u000a    else:\u000a        return trialList\u000a\u000adef createFactorialTrialList(factors):\u000a    """Create a trialList by entering a list of factors with names (keys) and levels (values)\u000a    it will return a trialList in which all factors have been factorially combined (so for example\u000a    if there are two factors with 3 and 5 levels the trialList will be a list of 3*5 = 15, each specifying\u000a    the values for a given trial\u000a\u000a    Usage::\u000a\u000a        trialList = createFactorialTrialList(factors)\u000a\u000a    :Parameters:\u000a\u000a        factors : a dictionary with names (keys) and levels (values) of the factors\u000a\u000a    Example::\u000a\u000a        mytrials = createFactorialTrialList( factors={"text": ["red", "green", "blue"],\u000a            "letterColor": ["red", "green"], "size": [0,1]})\u000a    """\u000a\u000a    # the first step is to place all the factorial combinations in a list of lists\u000a    tempListOfLists=[[]]\u000a    for key in factors:\u000a        alist = factors[key]   # this takes the levels of each factor as a set of values (a list) at a time\u000a        tempList = []\u000a        for value in alist:     # now we loop over the values in a given list, and add each value of the other lists\u000a            for iterList in tempListOfLists:\u000a                tempList.append(iterList + [key,value])\u000a        tempListOfLists = tempList\u000a\u000a    # this second step is so we can return a list in the format of trialList\u000a    trialList = []\u000a    for atrial in tempListOfLists:\u000a        keys = atrial[0::2]          #the even elements are keys\u000a        values = atrial[1::2]       #the odd elements are values\u000a        atrialDict = {}\u000a        for i in range(len(keys)):\u000a            atrialDict[keys[i]] = values[i]     #this combines the key with the value\u000a        trialList.append(atrialDict)             #append one trial at a time to the final trialList\u000a\u000a    return trialList\u000a\u000aclass StairHandler(_BaseTrialHandler):\u000a    """Class to handle smoothly the selection of the next trial\u000a    and report current values etc.\u000a    Calls to nextTrial() will fetch the next object given to this\u000a    handler, according to the method specified.\u000a\u000a    See ``demo_trialHandler.py``\u000a\u000a    The staircase will terminate when *nTrials* AND *nReversals* have been exceeded. If *stepSizes* was an array\u000a    and has been exceeded before nTrials is exceeded then the staircase will continue\u000a    to reverse\u000a\u000a    """\u000a    def __init__(self,\u000a                 startVal,\u000a                 nReversals=None,\u000a                 stepSizes=4,  #dB stepsize\u000a                 nTrials=0,\u000a                 nUp=1,\u000a                 nDown=3, #correct responses before stim goes down\u000a                 extraInfo=None,\u000a                 method = '2AFC',\u000a                 stepType='db',\u000a                 minVal=None,\u000a                 maxVal=None,\u000a                 originPath=None,\u000a                 name=''):\u000a        """\u000a        :Parameters:\u000a\u000a            startVal:\u000a                The initial value for the staircase.\u000a\u000a            nReversals:\u000a                The minimum number of reversals permitted. If stepSizes is a list then there must\u000a                also be enough reversals to satisfy this list.\u000a\u000a            stepSizes:\u000a                The size of steps as a single value or a list (or array). For a single value the step\u000a                size is fixed. For an array or list the step size will progress to the next entry\u000a                at each reversal.\u000a\u000a            nTrials:\u000a                The minimum number of trials to be conducted. If the staircase has not reached the\u000a                required number of reversals then it will continue.\u000a\u000a            nUp:\u000a                The number of 'incorrect' (or 0) responses before the staircase level increases.\u000a\u000a            nDown:\u000a                The number of 'correct' (or 1) responses before the staircase level decreases.\u000a\u000a            extraInfo:\u000a                A dictionary (typically) that will be stored along with collected data using\u000a                :func:`~psychopy.data.StairHandler.saveAsPickle` or\u000a                :func:`~psychopy.data.StairHandler.saveAsText` methods.\u000a\u000a            stepType:\u000a                specifies whether each step will be a jump of the given size in\u000a                'db', 'log' or 'lin' units ('lin' means this intensity will be added/subtracted)\u000a\u000a            method:\u000a                Not used and may be deprecated in future releases.\u000a\u000a            stepType: *'db'*, 'lin', 'log'\u000a                The type of steps that should be taken each time. 'lin' will simply add or subtract that\u000a                amount each step, 'db' and 'log' will step by a certain number of decibels or log units\u000a                (note that this will prevent your value ever reaching zero or less)\u000a\u000a            minVal: *None*, or a number\u000a                The smallest legal value for the staircase, which can be used to prevent it\u000a                reaching impossible contrast values, for instance.\u000a\u000a            maxVal: *None*, or a number\u000a                The largest legal value for the staircase, which can be used to prevent it\u000a                reaching impossible contrast values, for instance.\u000a\u000a        """\u000a\u000a        """\u000a        trialList: a simple list (or flat array) of trials.\u000a\u000a            """\u000a        self.name=name\u000a        self.startVal=startVal\u000a        self.nReversals=nReversals\u000a        self.nUp=nUp\u000a        self.nDown=nDown\u000a        self.extraInfo=extraInfo\u000a        self.method=method\u000a        self.stepType=stepType\u000a\u000a        self.stepSizes=stepSizes\u000a        if type(stepSizes) in [int, float]:\u000a            self.stepSizeCurrent=stepSizes\u000a            self._variableStep=False\u000a        else:#list, tuple or array\u000a            self.stepSizeCurrent=stepSizes[0]\u000a            self.nReversals= max(len(stepSizes),self.nReversals)\u000a            self._variableStep=True\u000a\u000a        self.nTrials = nTrials#to terminate the nTrials must be exceeded and either\u000a        self.finished=False\u000a        self.thisTrialN = -1\u000a        self.data = []\u000a        self.intensities=[]\u000a        self.reversalPoints = []\u000a        self.reversalIntensities=[]\u000a        self.currentDirection='start' #initially it goes down but on every step\u000a        self.correctCounter=0  #correct since last stim change (minus are incorrect)\u000a        self._nextIntensity=self.startVal\u000a        self._warnUseOfNext=True\u000a        self.minVal = minVal\u000a        self.maxVal = maxVal\u000a\u000a        #self.originPath and self.origin (the contents of the origin file)\u000a        self.originPath, self.origin = self.getOriginPathAndFile(originPath)\u000a        self._exp = None#the experiment handler that owns me!\u000a    def __iter__(self):\u000a        return self\u000a\u000a    def addData(self, result, intensity=None):\u000a        """Add a 1 or 0 to signify a correct/detected or incorrect/missed trial\u000a\u000a        This is essential to advance the staircase to a new intensity level!\u000a\u000a        Supplying an `intensity` value here indicates that you did not use the\u000a        recommended intensity in your last trial and the staircase will\u000a        replace its recorded value with the one you supplied here.\u000a        """\u000a        self.data.append(result)\u000a\u000a        #if needed replace the existing intensity with this custom one\u000a        if intensity!=None:\u000a            self.intensities.pop()\u000a            self.intensities.append(intensity)\u000a\u000a        #increment the counter of correct scores\u000a        if result==1:\u000a            if len(self.data)>1 and self.data[-2]==result:\u000a                #increment if on a run\u000a                self.correctCounter+=1\u000a            else:\u000a                #or reset\u000a                self.correctCounter = 1\u000a\u000a        else:\u000a            if  len(self.data)>1 and self.data[-2]==result:\u000a                #increment if on a run\u000a                self.correctCounter-=1\u000a            else:\u000a                #or reset\u000a                self.correctCounter = -1\u000a\u000a        if self.getExp()!=None:#update the experiment handler too\u000a            self.getExp().addData("%s.result" %(self.name), result)\u000a        self.calculateNextIntensity()\u000a\u000a    def calculateNextIntensity(self):\u000a        """based on current intensity, counter of correct responses and current direction"""\u000a\u000a        if len(self.reversalIntensities)<1:\u000a            #always using a 1-down, 1-up rule initially\u000a            if self.data[-1]==1:    #last answer correct\u000a                #got it right\u000a                self._intensityDec()\u000a                if self.currentDirection=='up':\u000a                    reversal=True\u000a                else:#direction is 'down' or 'start'\u000a                    reversal=False\u000a                    self.currentDirection='down'\u000a            else:\u000a                #got it wrong\u000a                self._intensityInc()\u000a                if self.currentDirection=='down':\u000a                    reversal=True\u000a                else:#direction is 'up' or 'start'\u000a                    reversal=False\u000a                #now:\u000a                self.currentDirection='up'\u000a\u000a        elif self.correctCounter >= self.nDown: #n right, time to go down!\u000a            #make it harder\u000a            self._intensityDec()\u000a            if self.currentDirection!='down':\u000a                reversal=True\u000a            else:\u000a                reversal=False\u000a            self.currentDirection='down'\u000a\u000a        elif self.correctCounter <= -self.nUp: #n wrong, time to go up!\u000a            #make it easier\u000a            self._intensityInc()\u000a            #note current direction\u000a            if self.currentDirection!='up':\u000a                reversal=True\u000a            else:\u000a                reversal=False\u000a            self.currentDirection='up'\u000a\u000a        else:\u000a            #same as previous trial\u000a            reversal=False\u000a\u000a\u000a        #add reversal info\u000a        if reversal:\u000a            self.reversalPoints.append(self.thisTrialN)\u000a            self.reversalIntensities.append(self.intensities[-1])\u000a        #test if we're done\u000a        if len(self.reversalIntensities)>=self.nReversals and \u005c\u000a            len(self.intensities)>=self.nTrials:\u000a                self.finished=True\u000a        #new step size if necessary\u000a        if reversal and self._variableStep and self.finished==False:\u000a            if len(self.reversalIntensities) >= len(self.stepSizes):\u000a                #we've gone beyond the list of step sizes so just use the last one\u000a                self.stepSizeCurrent = self.stepSizes[-1]\u000a            else:\u000a                self.stepSizeCurrent = self.stepSizes[len(self.reversalIntensities)]\u000a\u000a\u000a    def next(self):\u000a        """Advances to next trial and returns it.\u000a        Updates attributes; `thisTrial`, `thisTrialN` and `thisIndex`.\u000a\u000a        If the trials have ended, calling this method will raise a StopIteration error.\u000a        This can be handled with code such as::\u000a\u000a            staircase = StairHandler(.......)\u000a            for eachTrial in staircase:#automatically stops when done\u000a                #do stuff\u000a\u000a        or::\u000a\u000a            staircase = StairHandler(.......)\u000a            while True: #ie forever\u000a                try:\u000a                    thisTrial = staircase.next()\u000a                except StopIteration:#we got a StopIteration error\u000a                    break #break out of the forever loop\u000a                #do stuff here for the trial\u000a\u000a        """\u000a        if self.finished==False:\u000a            #update pointer for next trial\u000a            self.thisTrialN+=1\u000a            self.intensities.append(self._nextIntensity)\u000a            return self._nextIntensity\u000a        else:\u000a            self._terminate()\u000a    def _intensityInc(self):\u000a        """increment the current intensity and reset counter"""\u000a        if self.stepType=='db':\u000a            self._nextIntensity *= 10.0**(self.stepSizeCurrent/20.0)\u000a        elif self.stepType=='log':\u000a            self._nextIntensity *= 10.0**self.stepSizeCurrent\u000a        elif self.stepType=='lin':\u000a            self._nextIntensity += self.stepSizeCurrent\u000a        #check we haven't gone out of the legal range\u000a        if (self._nextIntensity > self.maxVal) and self.maxVal is not None:\u000a            self._nextIntensity = self.maxVal\u000a        self.correctCounter =0\u000a\u000a    def _intensityDec(self):\u000a        """decrement the current intensity and reset counter"""\u000a        if self.stepType=='db':\u000a            self._nextIntensity /= 10.0**(self.stepSizeCurrent/20.0)\u000a        if self.stepType=='log':\u000a            self._nextIntensity /= 10.0**self.stepSizeCurrent\u000a        elif self.stepType=='lin':\u000a            self._nextIntensity -= self.stepSizeCurrent\u000a        self.correctCounter =0\u000a        #check we haven't gone out of the legal range\u000a        if (self._nextIntensity < self.minVal) and self.minVal is not None:\u000a            self._nextIntensity = self.minVal\u000a\u000a    def saveAsText(self,fileName,\u000a                   delim='\u005ct',\u000a                   matrixOnly=False,\u000a                  ):\u000a        """\u000a        Write a text file with the data\u000a\u000a        :Parameters:\u000a\u000a            fileName: a string\u000a                The name of the file, including path if needed. The extension\u000a                `.dlm` will be added if not included.\u000a\u000a            delim: a string\u000a                the delimitter to be used (e.g. '\u005ct' for tab-delimitted, ',' for csv files)\u000a\u000a            matrixOnly: True/False\u000a                If True, prevents the output of the `extraInfo` provided at initialisation.\u000a        """\u000a\u000a        if self.thisTrialN<1:\u000a            logging.debug('StairHandler.saveAsText called but no trials completed. Nothing saved')\u000a            return -1\u000a\u000a        #create the file or print to stdout\u000a        if fileName=='stdout':\u000a            f = sys.stdout\u000a        elif fileName[-4:] in ['.dlm','.DLM', '.csv','.CSV']:\u000a            f= file(fileName,'w')\u000a        else:\u000a            if delim==',': f=file(fileName+'.csv','w')\u000a            else: f=file(fileName+'.dlm','w')\u000a\u000a        #write the data\u000a        reversalStr = str(self.reversalIntensities)\u000a        reversalStr = string.replace( reversalStr, ',', delim)\u000a        reversalStr = string.replace( reversalStr, '[', '')\u000a        reversalStr = string.replace( reversalStr, ']', '')\u000a        f.write('\u005cnreversalIntensities=\u005ct%s\u005cn' %reversalStr)\u000a\u000a        reversalPts = str(self.reversalPoints)\u000a        reversalPts = string.replace( reversalPts, ',', delim)\u000a        reversalPts = string.replace( reversalPts, '[', '')\u000a        reversalPts = string.replace( reversalPts, ']', '')\u000a        f.write('reversalIndices=\u005ct%s\u005cn' %reversalPts)\u000a\u000a        rawIntens = str(self.intensities)\u000a        rawIntens = string.replace( rawIntens, ',', delim)\u000a        rawIntens = string.replace( rawIntens, '[', '')\u000a        rawIntens = string.replace( rawIntens, ']', '')\u000a        f.write('\u005cnintensities=\u005ct%s\u005cn' %rawIntens)\u000a\u000a        responses = str(self.data)\u000a        responses = string.replace( responses, ',', delim)\u000a        responses = string.replace( responses, '[', '')\u000a        responses = string.replace( responses, ']', '')\u000a        f.write('responses=\u005ct%s\u005cn' %responses)\u000a\u000a        #add self.extraInfo\u000a        if (self.extraInfo != None) and not matrixOnly:\u000a            strInfo = str(self.extraInfo)\u000a            #dict begins and ends with {} - remove\u000a            strInfo = strInfo[1:-1] #string.replace(strInfo, '{','');strInfo = string.replace(strInfo, '}','');\u000a            strInfo = string.replace(strInfo, ': ', ':\u005cn')#separate value from keyname\u000a            strInfo = string.replace(strInfo, ',', '\u005cn')#separate values from each other\u000a            strInfo = string.replace(strInfo, 'array([ ', '')\u000a            strInfo = string.replace(strInfo, '])', '')\u000a\u000a            f.write('\u005cn%s\u005cn' %strInfo)\u000a\u000a        f.write("\u005cn")\u000a        if f != sys.stdout:\u000a            f.close()\u000a            logging.info('saved data to %s' %f.name)\u000a\u000a    def saveAsExcel(self,fileName, sheetName='data',\u000a                   matrixOnly=False, appendFile=True,\u000a                  ):\u000a        """\u000a        Save a summary data file in Excel OpenXML format workbook (:term:`xlsx`) for processing\u000a        in most spreadsheet packages. This format is compatible with\u000a        versions of Excel (2007 or greater) and and with OpenOffice (>=3.0).\u000a\u000a        It has the advantage over the simpler text files (see :func:`TrialHandler.saveAsText()` )\u000a        that data can be stored in multiple named sheets within the file. So you could have a single file\u000a        named after your experiment and then have one worksheet for each participant. Or you could have\u000a        one file for each participant and then multiple sheets for repeated sessions etc.\u000a\u000a        The file extension `.xlsx` will be added if not given already.\u000a\u000a        The file will contain a set of values specifying the staircase level ('intensity') at each\u000a        reversal, a list of reversal indices (trial numbers), the raw staircase/intensity\u000a        level on *every* trial and the corresponding responses of the participant on every trial.\u000a\u000a        :Parameters:\u000a\u000a            fileName: string\u000a                the name of the file to create or append. Can include relative or absolute path\u000a\u000a            sheetName: string\u000a                the name of the worksheet within the file\u000a\u000a            matrixOnly: True or False\u000a                If set to True then only the data itself will be output (no additional info)\u000a\u000a            appendFile: True or False\u000a                If False any existing file with this name will be overwritten. If True then a new worksheet will be appended.\u000a                If a worksheet already exists with that name a number will be added to make it unique.\u000a\u000a        """\u000a\u000a        if self.thisTrialN<1:\u000a            logging.debug('StairHandler.saveAsExcel called but no trials completed. Nothing saved')\u000a            return -1\u000a        #NB this was based on the limited documentation (1 page wiki) for openpyxl v1.0\u000a        if not haveOpenpyxl:\u000a            raise ImportError, 'openpyxl is required for saving files in Excel (xlsx) format, but was not found.'\u000a            return -1\u000a\u000a        #import necessary subpackages - they are small so won't matter to do it here\u000a        from openpyxl.workbook import Workbook\u000a        from openpyxl.writer.excel import ExcelWriter\u000a        from openpyxl.reader.excel import load_workbook\u000a\u000a        if not fileName.endswith('.xlsx'): fileName+='.xlsx'\u000a        #create or load the file\u000a        if appendFile and os.path.isfile(fileName):\u000a            wb = load_workbook(fileName)\u000a            newWorkbook=False\u000a        else:\u000a            if not appendFile: #the file exists but we're not appending, so will be overwritten\u000a                logging.warning('Data file, %s, will be overwritten' %fileName)\u000a            wb = Workbook()#create new workbook\u000a            wb.properties.creator='PsychoPy'+psychopy.__version__\u000a            newWorkbook=True\u000a\u000a        ew = ExcelWriter(workbook = wb)\u000a\u000a        if newWorkbook:\u000a            ws = wb.worksheets[0]\u000a            ws.title=sheetName\u000a        else:\u000a            ws=wb.create_sheet()\u000a            ws.title=sheetName\u000a\u000a        #write the data\u000a        #reversals data\u000a        ws.cell('A1').value = 'Reversal Intensities'\u000a        ws.cell('B1').value = 'Reversal Indices'\u000a        for revN, revIntens in enumerate(self.reversalIntensities):\u000a            ws.cell(_getExcelCellName(col=0,row=revN+1)).value = unicode(revIntens)\u000a            ws.cell(_getExcelCellName(col=1,row=revN+1)).value = unicode(self.reversalPoints[revN])\u000a\u000a        #trials data\u000a        ws.cell('C1').value = 'All Intensities'\u000a        ws.cell('D1').value = 'All Responses'\u000a        for intenN, intensity in enumerate(self.intensities):\u000a            ws.cell(_getExcelCellName(col=2,row=intenN+1)).value = unicode(intensity)\u000a            ws.cell(_getExcelCellName(col=3,row=intenN+1)).value = unicode(self.data[intenN])\u000a\u000a        #add self.extraInfo\u000a        rowN = 0\u000a        if (self.extraInfo != None) and not matrixOnly:\u000a            ws.cell(_getExcelCellName(col=6,row=rowN)).value = 'extraInfo'; rowN+=1\u000a            for key,val in self.extraInfo.items():\u000a                ws.cell(_getExcelCellName(col=6,row=rowN)).value = unicode(key)+u':'\u000a                ws.cell(_getExcelCellName(col=7,row=rowN)).value = unicode(val)\u000a                rowN+=1\u000a\u000a        ew.save(filename = fileName)\u000a        logging.info('saved data to %s' %fileName)\u000a\u000a    def saveAsPickle(self,fileName):\u000a        """Basically just saves a copy of self (with data) to a pickle file.\u000a\u000a        This can be reloaded if necess and further analyses carried out.\u000a        """\u000a        if self.thisTrialN<1:\u000a            logging.debug('StairHandler.saveAsPickle called but no trials completed. Nothing saved')\u000a            return -1\u000a        #otherwise use default location\u000a        f = open(fileName+'.psydat', "wb")\u000a        cPickle.dump(self, f)\u000a        f.close()\u000a        logging.info('saved data to %s' %f.name)\u000a\u000a\u000aclass QuestHandler(StairHandler):\u000a    """Class that implements the Quest algorithm for quick measurement of\u000a    psychophysical thresholds.\u000a\u000a    Uses Andrew Straw's `QUEST <http://www.visionegg.org/Quest>`_, which is a\u000a    Python port of Denis Pelli's Matlab code.\u000a\u000a    Measures threshold using a Weibull psychometric function. Currently, it is\u000a    not possible to use a different psychometric function.\u000a\u000a    Threshold 't' is measured on an abstract 'intensity' scale, which\u000a    usually corresponds to log10 contrast.\u000a\u000a    The Weibull psychometric function:\u000a\u000a    p2=delta*gamma+(1-delta)*(1-(1-gamma)*exp(-10**(beta*(x2+xThreshold))))\u000a\u000a    **Example**::\u000a\u000a        # setup display/window\u000a        ...\u000a        # create stimulus\u000a        stimulus = visual.RadialStim(win=win, tex='sinXsin', size=1, pos=[0,0], units='deg')\u000a        ...\u000a        # create staircase object\u000a        # trying to find out the point where subject's response is 50/50\u000a        # if wanted to do a 2AFC then the defaults for pThreshold and gamma are good\u000a        staircase = data.QuestHandler(staircase._nextIntensity, 0.2, pThreshold=0.63, gamma=0.01,\u000a                                  nTrials=20, minVal=0, maxVal=1)\u000a        ...\u000a        while thisContrast in staircase:\u000a            # setup stimulus\u000a            stimulus.setContrast(thisContrast)\u000a            stimulus.draw()\u000a            win.flip()\u000a            core.wait(0.5)\u000a            # get response\u000a            ...\u000a            # inform QUEST of the response, needed to calculate next level\u000a            staircase.addData(thisResp)\u000a        ...\u000a        # can now access 1 of 3 suggested threshold levels\u000a        staircase.mean()\u000a        staircase.mode()\u000a        staircase.quantile() #gets the median\u000a\u000a    """\u000a    def __init__(self,\u000a                 startVal,\u000a                 startValSd,\u000a                 pThreshold=0.82,\u000a                 nTrials=None,\u000a                 stopInterval=None,\u000a                 method='quantile',\u000a                 stepType='log',\u000a                 beta=3.5,\u000a                 delta=0.01,\u000a                 gamma=0.5,\u000a                 grain=0.01,\u000a                 range=None,\u000a                 extraInfo=None,\u000a                 minVal=None,\u000a                 maxVal=None,\u000a                 staircase=None,\u000a                 originPath=None,\u000a                 name=''):\u000a        """\u000a        Typical values for pThreshold are:\u000a            * 0.82 which is equivalent to a 3 up 1 down standard staircase\u000a            * 0.63 which is equivalent to a 1 up 1 down standard staircase (and might want gamma=0.01)\u000a\u000a        The variable(s) nTrials and/or stopSd must be specified.\u000a\u000a        `beta`, `delta`, and `gamma` are the parameters of the Weibull psychometric function.\u000a\u000a        :Parameters:\u000a\u000a            startVal:\u000a                Prior threshold estimate or your initial guess threshold.\u000a\u000a            startValSd:\u000a                Standard deviation of your starting guess threshold. Be generous with the sd\u000a                as QUEST will have trouble finding the true threshold if it's more than one sd\u000a                from your initial guess.\u000a\u000a            pThreshold\u000a                Your threshold criterion expressed as probability of response==1. An intensity\u000a                offset is introduced into the psychometric function so that the threshold (i.e.,\u000a                the midpoint of the table) yields pThreshold..\u000a\u000a            nTrials: *None* or a number\u000a                The maximum number of trials to be conducted.\u000a\u000a            stopInterval: *None* or a number\u000a                The minimum 5-95% confidence interval required in the threshold estimate before stopping.\u000a                If both this and nTrials is specified, whichever happens first will determine when\u000a                Quest will stop.\u000a\u000a            method: *'quantile'*, 'mean', 'mode'\u000a                The method used to determine the next threshold to test. If you want to get a specific threshold\u000a                level at the end of your staircasing, please use the quantile, mean, and mode methods directly.\u000a\u000a            stepType: *'log'*, 'db', 'lin'\u000a                The type of steps that should be taken each time. 'db' and 'log' will transform your intensity levels\u000a                into decibels or log units and will move along the psychometric function with these values.\u000a\u000a            beta: *3.5* or a number\u000a                Controls the steepness of the psychometric function.\u000a\u000a            delta: *0.01* or a number\u000a                The fraction of trials on which the observer presses blindly.\u000a\u000a            gamma: *0.5* or a number\u000a                The fraction of trials that will generate response 1 when intensity=-Inf.\u000a\u000a            grain: *0.01* or a number\u000a                The quantization of the internal table.\u000a\u000a            range: *None*, or a number\u000a                The intensity difference between the largest and smallest intensity that the\u000a                internal table can store. This interval will be centered on the initial guess\u000a                tGuess. QUEST assumes that intensities outside of this range have zero prior\u000a                probability (i.e., they are impossible).\u000a\u000a            extraInfo:\u000a                A dictionary (typically) that will be stored along with collected data using\u000a                :func:`~psychopy.data.StairHandler.saveAsPickle` or\u000a                :func:`~psychopy.data.StairHandler.saveAsText` methods.\u000a\u000a            minVal: *None*, or a number\u000a                The smallest legal value for the staircase, which can be used to prevent it\u000a                reaching impossible contrast values, for instance.\u000a\u000a            maxVal: *None*, or a number\u000a                The largest legal value for the staircase, which can be used to prevent it\u000a                reaching impossible contrast values, for instance.\u000a\u000a            staircase: *None* or StairHandler\u000a                Can supply a staircase object with intensities and results. Might be useful to\u000a                give the quest algorithm more information if you have it. You can also call the\u000a                importData function directly.\u000a\u000a        """\u000a\u000a        # Initialize using parent class first\u000a        StairHandler.__init__(self, startVal, nTrials=nTrials, extraInfo=extraInfo, method=method,\u000a                                stepType=stepType, minVal=minVal, maxVal=maxVal, name=name)\u000a\u000a        # Setup additional values\u000a        self.stopInterval = stopInterval\u000a\u000a        # Transform startVal and startValSd based on stepType\u000a        startVal = self._intensity2scale(startVal)\u000a        startValSd = self._intensity2scale(startValSd)\u000a        self._questNextIntensity = startVal\u000a\u000a        # Create Quest object\u000a        self._quest = QuestObject(startVal, startValSd, pThreshold, beta, delta, gamma, grain, range)\u000a\u000a        # Import any old staircase data\u000a        if staircase is not None:\u000a            self.importData(staircase.intensities, staircase.data)\u000a        #store the origin file and its path\u000a        self.originPath, self.origin = self.getOriginPathAndFile(originPath)\u000a        self._exp=None\u000a\u000a    def addData(self, result, intensity=None):\u000a        """Add a 1 or 0 to signify a correct/detected or incorrect/missed trial\u000a\u000a        Supplying an `intensity` value here indicates that you did not use the\u000a        recommended intensity in your last trial and the staircase will\u000a        replace its recorded value with the one you supplied here.\u000a        """\u000a        # Process user supplied intensity\u000a        if intensity is None:\u000a            intensity = self._questNextIntensity\u000a        else:\u000a            intensity = self._intensity2scale(intensity)\u000a            #update the intensity\u000a            self.intensities.pop()#remove the one that had been auto-generated\u000a            self.intensities.append(intensity)\u000a        # Update quest\u000a        self._quest.update(intensity, result)\u000a        # Update other things\u000a        self.data.append(result)\u000a        if self.getExp()!=None:\u000a            self.getExp().addData('response', result)\u000a        self.calculateNextIntensity()\u000a\u000a    def importData(self, intensities, results):\u000a        """import some data which wasn't previously given to the quest algorithm"""\u000a        # NOT SURE ABOUT CLASS TO USE FOR RAISING ERROR\u000a        if len(intensities) != len(results):\u000a            raise AttributeError, "length of intensities and results input must be the same"\u000a        self.incTrials(len(intensities))\u000a        for intensity, result in zip(intensities,results):\u000a            try:\u000a                self.next()\u000a                self.addData(result, intensity)\u000a            except StopIteration:   # would get a stop iteration if stopInterval set\u000a                pass    # TODO: might want to check if nTrials is still good\u000a\u000a    def calculateNextIntensity(self):\u000a        """based on current intensity and counter of correct responses"""\u000a        self._intensity()\u000a        # Check we haven't gone out of the legal range\u000a        if (self._nextIntensity > self.maxVal) and self.maxVal is not None:\u000a            self._nextIntensity = self.maxVal\u000a        elif (self._nextIntensity < self.minVal) and self.minVal is not None:\u000a            self._nextIntensity = self.minVal\u000a        self._questNextIntensity = self._intensity2scale(self._nextIntensity)\u000a    def _intensity(self):\u000a        """assigns the next intensity level"""\u000a        if self.method == 'mean':\u000a            self._questNextIntensity = self._quest.mean()\u000a        elif self.method == 'mode':\u000a            self._questNextIntensity = self._quest.mode()\u000a        elif self.method == 'quantile':\u000a            self._questNextIntensity = self._quest.quantile()\u000a        # else: maybe raise an error\u000a        self._nextIntensity = self._scale2intensity(self._questNextIntensity)\u000a\u000a    def _intensity2scale(self, intensity):\u000a        """returns the scaled intensity level based on value of self.stepType"""\u000a        if self.stepType=='db':\u000a            scaled_intensity = numpy.log10(intensity) * 20.0\u000a        elif self.stepType=='log':\u000a            scaled_intensity = numpy.log10(intensity)\u000a        else:\u000a            scaled_intensity = intensity\u000a        return scaled_intensity\u000a\u000a    def _scale2intensity(self, scaled_intensity):\u000a        """returns the unscaled intensity level based on value of self.stepType"""\u000a        if self.stepType=='db':\u000a            intensity = 10.0**(scaled_intensity/20.0)\u000a        elif self.stepType=='log':\u000a            intensity = 10.0**scaled_intensity\u000a        else:\u000a            intensity = scaled_intensity\u000a        return intensity\u000a\u000a    def mean(self):\u000a        """mean of Quest posterior pdf"""\u000a        return self._scale2intensity(self._quest.mean())\u000a\u000a    def sd(self):\u000a        """standard deviation of Quest posterior pdf"""\u000a        return self._scale2intensity(self._quest.sd())\u000a\u000a    def mode(self):\u000a        """mode of Quest posterior pdf"""\u000a        return self._scale2intensity(self._quest.mode()[0])\u000a\u000a    def quantile(self, p=None):\u000a        """quantile of Quest posterior pdf"""\u000a        return self._scale2intensity(self._quest.quantile(p))\u000a\u000a    def confInterval(self, getDifference=False):\u000a        """give the range of the 5-95% confidence interval"""\u000a        interval = [self.quantile(0.05), self.quantile(0.95)]\u000a        if getDifference:\u000a            return abs(interval[0] - interval[1])\u000a        else:\u000a            return interval\u000a\u000a    def incTrials(self, nNewTrials):\u000a        """increase maximum number of trials\u000a        Updates attribute: `nTrials`\u000a        """\u000a        self.nTrials += nNewTrials\u000a\u000a    def simulate(self, tActual):\u000a        """ returns a simulated user response to the next intensity level presented by Quest,\u000a            need to supply the actual threshold level\u000a        """\u000a        # Current estimated intensity level\u000a        if self.method == 'mean':\u000a            tTest = self._quest.mean()\u000a        elif self.method == 'mode':\u000a            tTest = self._quest.mode()\u000a        elif self.method == 'quantile':\u000a            tTest = self._quest.quantile()\u000a        return self._quest.simulate(tTest, tActual)\u000a\u000a    def next(self):\u000a        """Advances to next trial and returns it.\u000a        Updates attributes; `thisTrial`, `thisTrialN`, `thisIndex`, `finished`, `intensities`\u000a\u000a        If the trials have ended, calling this method will raise a StopIteration error.\u000a        This can be handled with code such as::\u000a\u000a            staircase = QuestHandler(.......)\u000a            for eachTrial in staircase:#automatically stops when done\u000a                #do stuff\u000a\u000a        or::\u000a\u000a            staircase = QuestHandler(.......)\u000a            while True: #ie forever\u000a                try:\u000a                    thisTrial = staircase.next()\u000a                except StopIteration:#we got a StopIteration error\u000a                    break #break out of the forever loop\u000a                #do stuff here for the trial\u000a        """\u000a        self._checkFinished()\u000a\u000a        if self.finished==False:\u000a            #update pointer for next trial\u000a            self.thisTrialN+=1\u000a            self.intensities.append(self._nextIntensity)\u000a            return self._nextIntensity\u000a        else:\u000a            self._terminate()\u000a\u000a    def _checkFinished(self):\u000a        """checks if we are finished\u000a        Updates attribute: `finished`\u000a        """\u000a        if self.nTrials is not None and len(self.intensities) >= self.nTrials:\u000a            self.finished = True\u000a        elif self.stopInterval is not None and self.confInterval(True) < self.stopInterval:\u000a            self.finished = True\u000a        else:\u000a            self.finished = False\u000a\u000a\u000aclass MultiStairHandler(_BaseTrialHandler):\u000a    def __init__(self, stairType='simple', method='random',\u000a            conditions=None, nTrials=50, originPath=None, name=''):\u000a        """A Handler to allow easy interleaved staircase procedures (simple or\u000a        QUEST).\u000a\u000a        Parameters for the staircases, as used by the relevant :class:`StairHandler` or\u000a        :class:`QuestHandler` (e.g. the `startVal`, `minVal`, `maxVal`...)\u000a        should be specified in the `conditions` list and may vary between\u000a        each staircase. In particular, the conditions /must/ include the\u000a        a `startVal` (because this is a required argument to the above handlers)\u000a        a `label` to tag the staircase and a `startValSd` (only for QUEST\u000a        staircases). Any parameters not specified in the conditions file\u000a        will revert to the default for that individual handler.\u000a\u000a        If you need to custom the behaviour further you may want to look at the\u000a        recipe on :ref:`interleavedStairs`.\u000a\u000a        :params:\u000a\u000a            stairType: 'simple' or 'quest'\u000a                Use a :class:`StairHandler` or :class:`QuestHandler`\u000a\u000a            method: 'random' or 'sequential'\u000a                The stairs are shuffled in each repeat but not randomised more than\u000a                that (so you can't have 3 repeats of the same staircase in a row\u000a                unless it's the only one still running)\u000a\u000a            conditions: a list of dictionaries specifying conditions\u000a                Can be used to control parameters for the different staicases.\u000a                Can be imported from an Excel file using `psychopy.data.importTrialTypes`\u000a                MUST include keys providing, 'startVal', 'label' and 'startValSd' (QUEST only).\u000a                The 'label' will be used in data file saving so should be unique.\u000a                See Example Usage below.\u000a\u000a            nTrials=50\u000a                Minimum trials to run (but may take more if the staircase hasn't\u000a                also met its minimal reversals. See `~psychopy.data.StairHandler`\u000a\u000a        Example usage::\u000a\u000a            conditions=[\u000a                {'label':'low', 'startVal': 0.1, 'ori':45},\u000a                {'label':'high','startVal': 0.8, 'ori':45},\u000a                {'label':'low', 'startVal': 0.1, 'ori':90},\u000a                {'label':'high','startVal': 0.8, 'ori':90},\u000a                ]\u000a            stairs = MultiStairHandler(conditions=conditions, nTrials=50)\u000a\u000a            for thisIntensity, thisCondition in stairs:\u000a                thisOri = thisCondition['ori']\u000a\u000a                #do something with thisIntensity and thisOri\u000a\u000a                stairs.addData(correctIncorrect)#this is ESSENTIAL\u000a\u000a            #save data as multiple formats\u000a            stairs.saveDataAsExcel(fileName)#easy to browse\u000a            stairs.saveAsPickle(fileName)#contains more info\u000a\u000a        """\u000a        self.name=name\u000a        self.type=stairType\u000a        self.method=method #'random' or 'sequential'\u000a        self.conditions=conditions\u000a        self.nTrials=nTrials\u000a        self.finished=False\u000a        self.totalTrials=0\u000a        self._checkArguments()\u000a        #create staircases\u000a        self.staircases=[]#all staircases\u000a        self.runningStaircases=[]#staircases that haven't finished yet\u000a        self.thisPassRemaining=[]#staircases to run this pass\u000a        self._createStairs()\u000a\u000a        #fetch first staircase/value (without altering/advancing it)\u000a        self._startNewPass()\u000a        self.currentStaircase = self.thisPassRemaining[0]#take the first and remove it\u000a        self._nextIntensity = self.currentStaircase._nextIntensity#gets updated by self.addData()\u000a        #store the origin file and its path\u000a        self.originPath, self.origin = self.getOriginPathAndFile(originPath)\u000a        self._exp = None#the experiment handler that owns me!\u000a    def _checkArguments(self):\u000a        #did we get a conditions parameter, correctly formatted\u000a        if type(self.conditions) not in [list]:\u000a            logging.error('conditions parameter to MultiStairHandler should be a list, not a %s' %type(self.conditions))\u000a            return\u000a        c0=self.conditions[0]\u000a        if type(c0)!=dict:\u000a            logging.error('conditions to MultiStairHandler should be a list of python dictionaries' + \u005c\u000a                ', not a list of %ss' %type(c0))\u000a        #did conditions contain the things we need?\u000a        params = c0.keys()\u000a        if self.type in ['simple','quest']:\u000a            if 'startVal' not in params:\u000a                logging.error('MultiStairHandler needs a param called `startVal` in conditions')\u000a            if 'label' not in params:\u000a                logging.error('MultiStairHandler needs a param called `label` in conditions')\u000a            if 'startValSd' not in params and self.type=='quest':\u000a                logging.error("MultiStairHandler('quest') needs a param called `startValSd` in conditions")\u000a        else:\u000a            logging.error("MultiStairHandler `stairType` should be 'simple' or 'quest', not '%s'" %self.type)\u000a    def _createStairs(self):\u000a        if self.type=='simple':\u000a            defaults = {'nReversals':None, 'stepSizes':4, 'nTrials':self.nTrials,\u000a                'nUp':1, 'nDown':3, 'extraInfo':None,\u000a                'stepType':'db', 'minVal':None, 'maxVal':None}\u000a        elif self.type=='quest':\u000a            defaults = {'pThreshold':0.82, 'nTrials':self.nTrials, 'stopInterval':None,\u000a                'method':'quantile', 'stepType':'log', 'beta':3.5, 'delta':0.01,\u000a                'gamma':0.5, 'grain':0.01, 'range':None, 'extraInfo':None,\u000a                'minVal':None, 'maxVal':None, 'staircase':None}\u000a\u000a        for condition in self.conditions:\u000a            startVal=condition['startVal']\u000a            #fetch each params from conditions if possible\u000a            for paramName in defaults:\u000a                #get value for the parameter\u000a                if paramName in condition.keys(): val=condition[paramName]\u000a                else: val = defaults[paramName]\u000a                #assign value to variable name\u000a                exec('%s=%s' %(paramName, repr(val)))\u000a            #then create actual staircase\u000a            if self.type=='simple':\u000a                thisStair = StairHandler(startVal, nReversals=nReversals,\u000a                    stepSizes=stepSizes, nTrials=nTrials, nUp=nUp, nDown=nDown,\u000a                    extraInfo=extraInfo,\u000a                    stepType=stepType, minVal=minVal, maxVal=maxVal)\u000a            elif self.type=='quest':\u000a                thisStair = QuestHandler(startVal, startValSd=condition['startValSd'],\u000a                    pThreshold=pThreshold, nTrials=nTrials, stopInterval=stopInterval,\u000a                    method=method, stepType=stepType, beta=beta, delta=delta,\u000a                    gamma=gamma, grain=grain, range=range, extraInfo=extraInfo,\u000a                    minVal=minVal, maxVal=maxVal, staircase=staircase)\u000a            thisStair.condition = condition#this isn't normally part of handler\u000a            #and finally, add it to the list\u000a            self.staircases.append(thisStair)\u000a            self.runningStaircases.append(thisStair)\u000a    def __iter__(self):\u000a        return self\u000a    def next(self):\u000a        """Advances to next trial and returns it.\u000a\u000a        This can be handled with code such as::\u000a\u000a            staircase = MultiStairHandler(.......)\u000a            for eachTrial in staircase:#automatically stops when done\u000a                #do stuff here for the trial\u000a\u000a        or::\u000a\u000a            staircase = MultiStairHandler(.......)\u000a            while True: #ie forever\u000a                try:\u000a                    thisTrial = staircase.next()\u000a                except StopIteration:#we got a StopIteration error\u000a                    break #break out of the forever loop\u000a                #do stuff here for the trial\u000a\u000a        """\u000a        #create a new set for this pass if needed\u000a        if not hasattr(self, 'thisPassRemaining') or self.thisPassRemaining==[]:\u000a            if len(self.runningStaircases)>0:\u000a                self._startNewPass()\u000a            else:\u000a                self.finished=True\u000a                raise StopIteration\u000a        #fetch next staircase/value\u000a        self.currentStaircase = self.thisPassRemaining.pop(0)#take the first and remove it\u000a        self._nextIntensity = self.currentStaircase._nextIntensity#gets updated by self.addData()\u000a        #return value\u000a        if self.finished==False:\u000a            return self._nextIntensity, self.currentStaircase.condition\u000a        else:\u000a            raise StopIteration\u000a\u000a    def _startNewPass(self):\u000a        """Create a new iteration of the running staircases for this pass.\u000a\u000a        This is not normally needed byt he user - it gets called at __init__\u000a        and every time that next() runs out of trials for this pass.\u000a        """\u000a        self.thisPassRemaining = copy.copy(self.runningStaircases)\u000a        if self.method=='random': numpy.random.shuffle(self.thisPassRemaining)\u000a    def addData(self, result, intensity=None):\u000a        """Add a 1 or 0 to signify a correct/detected or incorrect/missed trial\u000a\u000a        This is essential to advance the staircase to a new intensity level!\u000a        """\u000a        self.currentStaircase.addData(result)\u000a        if self.getExp()!=None:#update the experiment handler too\u000a            self.getExp().addData('response', result)\u000a        try:\u000a            self.currentStaircase.next()\u000a        except:\u000a            self.runningStaircases.remove(self.currentStaircase)\u000a        self.totalTrials+=1\u000a    def saveAsPickle(self, fileName):\u000a        """Saves a copy of self (with data) to a pickle file.\u000a\u000a        This can be reloaded later and further analyses carried out.\u000a        """\u000a        if self.totalTrials<1:\u000a            logging.debug('StairHandler.saveAsPickle called but no trials completed. Nothing saved')\u000a            return -1\u000a        #otherwise use default location\u000a        f = open(fileName+'.psydat', "wb")\u000a        cPickle.dump(self, f)\u000a        f.close()\u000a        logging.info('saved data to %s' %f.name)\u000a    def saveAsExcel(self, fileName, matrixOnly=False, appendFile=False):\u000a        """\u000a        Save a summary data file in Excel OpenXML format workbook (:term:`xlsx`) for processing\u000a        in most spreadsheet packages. This format is compatible with\u000a        versions of Excel (2007 or greater) and and with OpenOffice (>=3.0).\u000a\u000a        It has the advantage over the simpler text files (see :func:`TrialHandler.saveAsText()` )\u000a        that the data from each staircase will be save in the same file, with\u000a        the sheet name coming from the 'label' given in the dictionary of\u000a        conditions during initialisation of the Handler.\u000a\u000a        The file extension `.xlsx` will be added if not given already.\u000a\u000a        The file will contain a set of values specifying the staircase level ('intensity') at each\u000a        reversal, a list of reversal indices (trial numbers), the raw staircase/intensity\u000a        level on *every* trial and the corresponding responses of the participant on every trial.\u000a\u000a        :Parameters:\u000a\u000a            fileName: string\u000a                the name of the file to create or append. Can include relative or absolute path\u000a\u000a            matrixOnly: True or False\u000a                If set to True then only the data itself will be output (no additional info)\u000a\u000a            appendFile: True or False\u000a                If False any existing file with this name will be overwritten. If True then a new worksheet will be appended.\u000a                If a worksheet already exists with that name a number will be added to make it unique.\u000a\u000a        """\u000a        if self.totalTrials<1:\u000a            logging.debug('StairHandler.saveAsExcel called but no trials completed. Nothing saved')\u000a            return -1\u000a        for stairN, thisStair in enumerate(self.staircases):\u000a            if stairN==0: append=appendFile\u000a            else: append=True\u000a            #make a filename\u000a            label = thisStair.condition['label']\u000a            thisStair.saveAsExcel(fileName=fileName, sheetName=label,\u000a                matrixOnly=False, appendFile=append)\u000a    def saveAsText(self,fileName,\u000a                   delim='\u005ct',\u000a                   matrixOnly=False):\u000a        """\u000a        Write out text files with the data.\u000a\u000a        For MultiStairHandler this will output one file for each staircase\u000a        that was run, with _label added to the fileName that you specify above\u000a        (label comes from the condition dictionary you specified when you\u000a        created the Handler).\u000a\u000a        :Parameters:\u000a\u000a            fileName: a string\u000a                The name of the file, including path if needed. The extension\u000a                `.dlm` will be added if not included.\u000a\u000a            delim: a string\u000a                the delimitter to be used (e.g. '\u005ct' for tab-delimitted, ',' for csv files)\u000a\u000a            matrixOnly: True/False\u000a                If True, prevents the output of the `extraInfo` provided at initialisation.\u000a        """\u000a        if self.totalTrials<1:\u000a            logging.debug('StairHandler.saveAsText called but no trials completed. Nothing saved')\u000a            return -1\u000a        for stairN, thisStair in enumerate(self.staircases):\u000a            #make a filename\u000a            label = thisStair.condition['label']\u000a            thisFileName = fileName+"_"+label\u000a            thisStair.saveAsText(fileName=thisFileName, delim=delim,\u000a                matrixOnly=matrixOnly)\u000a    def printAsText(self,\u000a                   delim='\u005ct',\u000a                   matrixOnly=False):\u000a        """\u000a        Write the data to the standard output stream\u000a\u000a        :Parameters:\u000a\u000a            delim: a string\u000a                the delimitter to be used (e.g. '\u005ct' for tab-delimitted, ',' for csv files)\u000a\u000a            matrixOnly: True/False\u000a                If True, prevents the output of the `extraInfo` provided at initialisation.\u000a        """\u000a        nStairs=len(self.staircases)\u000a        for stairN, thisStair in enumerate(self.staircases):\u000a            if stairN<(nStairs-1): thisMatrixOnly=True #never print info for first files\u000a            else: thisMatrixOnly = matrixOnly\u000a            #make a filename\u000a            label = thisStair.condition['label']\u000a            print "\u005cn%s:" %label\u000a            thisStair.saveAsText(fileName='stdout', delim=delim,\u000a                matrixOnly=thisMatrixOnly)\u000a\u000aclass DataHandler(dict):\u000a    """For handling data (used by TrialHandler, principally, rather than\u000a    by users directly)\u000a\u000a    Numeric data are stored as numpy masked arrays where the mask is set True for missing entries.\u000a    When any non-numeric data (string, list or array) get inserted using DataHandler.add(val) the array\u000a    is converted to a standard (not masked) numpy array with dtype='O' and where missing entries have\u000a    value="--"\u000a\u000a    Attributes:\u000a        - ['key']=data arrays containing values for that key\u000a            (e.g. data['accuracy']=...)\u000a        - dataShape=shape of data (x,y,...z,nReps)\u000a        - dataTypes=list of keys as strings\u000a\u000a    """\u000a    def __init__(self, dataTypes=None, trials=None, dataShape=None):\u000a        self.trials=trials\u000a        self.dataTypes=[]#names will be added during addDataType\u000a        self.isNumeric={}\u000a        #if given dataShape use it - otherwise guess!\u000a        if dataShape: self.dataShape=dataShape\u000a        elif self.trials:\u000a            self.dataShape=list(numpy.asarray(trials.trialList,'O').shape)\u000a            self.dataShape.append(trials.nReps)\u000a\u000a        #initialise arrays now if poss\u000a        if dataTypes and self.dataShape:\u000a            for thisType in dataTypes:\u000a                self.addDataType(thisType)\u000a\u000a    def addDataType(self, names, shape=None):\u000a        """Add a new key to the data dictionary of\u000a        particular shape if specified (otherwise the\u000a        shape of the trial matrix in the trial handler.\u000a        Data are initialised to be zero everywhere.\u000a        Not needed by user: appropriate types will be added\u000a        during initialisation and as each xtra type is needed.\u000a        """\u000a        if not shape: shape = self.dataShape\u000a        if not isinstance(names,basestring):\u000a            #recursively call this function until we have a string\u000a            for thisName in names: self.addDataType(thisName)\u000a        else:\u000a            #create the appropriate array in the dict\u000a            #initially use numpy masked array of floats with mask=True for missing vals\u000a            #convert to a numpy array with dtype='O' if non-numeric data given\u000a            #NB don't use masked array with dytpe='O' together -they don't unpickle\u000a            self[names]=numpy.ma.zeros(shape,'f')#masked array of floats\u000a            self[names].mask=True\u000a            #add the name to the list\u000a            self.dataTypes.append(names)\u000a            self.isNumeric[names]=True#until we need otherwise\u000a    def add(self, thisType, value, position=None):\u000a        """Add data to an existing data type\u000a        (and add a new one if necess)\u000a        """\u000a        if not self.has_key(thisType):\u000a            self.addDataType(thisType)\u000a        if position==None:\u000a            #'ran' is always the first thing to update\u000a            if thisType=='ran':\u000a                repN = sum(self['ran'][self.trials.thisIndex])\u000a            else:\u000a                repN = sum(self['ran'][self.trials.thisIndex])-1#because it has already been updated\u000a            #make a list where 1st digit is trial number\u000a            position= [self.trials.thisIndex]\u000a            position.append(repN)\u000a\u000a        #check whether data falls within bounds\u000a        posArr = numpy.asarray(position)\u000a        shapeArr = numpy.asarray(self.dataShape)\u000a        if not numpy.alltrue(posArr<shapeArr):\u000a            #array isn't big enough\u000a            logging.warning('need a bigger array for:'+thisType)\u000a            self[thisType]=misc.extendArr(self[thisType],posArr)#not implemented yet!\u000a        #check for ndarrays with more than one value and for non-numeric data\u000a        if self.isNumeric[thisType] and \u005c\u000a            ((type(value)==numpy.ndarray and len(value)>1) or (type(value) not in [float, int])):\u000a                self._convertToObjectArray(thisType)\u000a        #insert the value\u000a        self[thisType][position[0],position[1]]=value\u000a    def _convertToObjectArray(self, thisType):\u000a        """Convert this datatype from masked numeric array to unmasked object array\u000a        """\u000a        dat = self[thisType]\u000a        self[thisType] = numpy.array(dat.data, dtype='O')#create an array of Object type\u000a        #masked vals should be "--", others keep data\u000a        self[thisType] = numpy.where(dat.mask, '--',dat).astype('O')#we have to repeat forcing to 'O' or text gets truncated to 4chars\u000a        self.isNumeric[thisType]=False\u000a\u000aclass FitFunction:\u000a    """Deprecated - use the specific functions; FitWeibull, FitLogistic...\u000a    """\u000a\u000a    def __init__(self, fnName, xx, yy, sems=1.0, guess=None, display=1,\u000a                 expectedMin=0.5):\u000a        self.fnName = fnName\u000a        self.xx = numpy.asarray(xx)\u000a        self.yy = numpy.asarray(yy)\u000a        self.sems = numpy.asarray(sems)\u000a        self.params = guess\u000a        self.display=display\u000a        # for holding error calculations:\u000a        self.ssq=0\u000a        self.rms=0\u000a        self.chi=0\u000a\u000a        if fnName[-4:] in ['2AFC', 'TAFC']:\u000a            self.expectedMin = 0.5\u000a        elif fnName[-2:] =='YN':\u000a            self.expectedMin=0.0\u000a        else:\u000a            self.expectedMin=expectedMin\u000a\u000a        #do the calculations:\u000a        self._doFit()\u000a\u000a    def _doFit(self):\u000a        #get some useful variables to help choose starting fit vals\u000a        xMin = min(self.xx); xMax = max(self.xx)\u000a        xRange=xMax-xMin; xMean= (xMax+xMin)/2.0\u000a        if self.fnName in ['weibullTAFC','weibullYN']:\u000a            if self.params==None: guess=[xMean, xRange/5.0]\u000a            else: guess= numpy.asarray(self.params,'d')\u000a        elif self.fnName in ['cumNorm','erf']:\u000a            if self.params==None: guess=[xMean, xRange/5.0]#c50, xScale (slope)\u000a            else: guess= numpy.asarray(self.params,'d')\u000a        elif self.fnName in ['logisticTAFC','logistYN', 'logistic']:\u000a            if self.params==None: guess=[xMin, 5.0/xRange]#x0, xRate\u000a            else: guess= numpy.asarray(self.params,'d')\u000a        elif self.fnName in ['nakaRush', 'nakaRushton', 'NR']:\u000a            if self.params==None: guess=[xMean, 2.0]#x50, expon\u000a            else: guess= numpy.asarray(self.params,'d')\u000a\u000a        self.params = optimize.fmin_cg(self._getErr, guess, None, (self.xx,self.yy,self.sems),disp=self.display)\u000a        self.ssq = self._getErr(self.params, self.xx, self.yy, 1.0)\u000a        self.chi = self._getErr(self.params, self.xx, self.yy, self.sems)\u000a        self.rms = self.ssq/len(self.xx)\u000a\u000a    def _getErr(self, params, xx,yy,sems):\u000a        mod = self.eval(xx, params)\u000a        err = sum((yy-mod)**2/sems)\u000a        return err\u000a\u000a    def eval(self, xx=None, params=None):\u000a        if xx==None: xx=self.xx\u000a        if params==None: params=self.params\u000a        if self.fnName in ['weibullTAFC', 'weibull2AFC']:\u000a            alpha = params[0];\u000a            if alpha<=0: alpha=0.001\u000a            beta = params[1]\u000a            xx = numpy.asarray(xx)\u000a            yy =  1.0 - 0.5*numpy.exp( - (xx/alpha)**beta )\u000a        elif self.fnName == 'weibullYN':\u000a            alpha = params[0];\u000a            if alpha<=0: alpha=0.001\u000a            beta = params[1]\u000a            xx = numpy.asarray(xx)\u000a            yy =  1.0 - numpy.exp( - (xx/alpha)**beta )\u000a        elif self.fnName in ['nakaRush', 'nakaRushton', 'NR']:\u000a            c50 = params[0]\u000a            if c50<=0: c50=0.001\u000a            n = params[1]\u000a            if n<=0: n=0.001\u000a            xx = numpy.asarray(xx)\u000a            yy = rMax*(xx**n/(xx**n+c50**n))\u000a        elif self.fnName in [ 'erf', 'cumNorm']:\u000a            xShift = params[0]\u000a            xScale = params[1]\u000a            if xScale<=0: xScale=0.001\u000a            xx = numpy.asarray(xx)\u000a            yy = special.erf(xx*xScale - xShift)*0.5+0.5#numpy.special.erf() goes from -1:1\u000a        elif self.fnName in [ 'logisticYN', 'logistYN']:\u000a            x0 = params[0]\u000a            xRate = params[1]\u000a            if xRate<=0: xRate=0.001\u000a            xx = numpy.asarray(xx)\u000a            yy = 1.0/(1+(1.0/x0-1)*numpy.exp(-xRate*xx))\u000a        return yy\u000a\u000a    def inverse(self, yy, params=None):\u000a        """Returns fitted xx for any given yy value(s).\u000a\u000a        If params is specified this will override the current model params.\u000a        """\u000a        yy = numpy.asarray(yy)\u000a        if params==None: params=self.params\u000a        if self.fnName== 'weibullTAFC':\u000a            alpha = params[0]\u000a            beta = params[1]\u000a            xx = alpha * (-numpy.log(2.0 * (1.0-yy))) **(1.0/beta)\u000a        elif self.fnName== 'weibullYN':\u000a            alpha = params[0]\u000a            beta = params[1]\u000a            xx = alpha * (-numpy.log(1.0-yy))**(1.0/beta)\u000a        elif self.fnName in [ 'erf', 'cumNorm']:\u000a            xShift = params[0]\u000a            xScale = params[1]\u000a            xx = (special.erfinv(yy*2.0-1.0)+xShift)/xScale\u000a        elif self.fnName in [ 'logisticYN', 'logistYN']:\u000a            x0 = params[0]\u000a            xRate = params[1]\u000a            xx = -numpy.log( (1/yy-1)/(1/x0-1) )/xRate\u000a        elif self.fnName in ['nakaRush', 'nakaRushton', 'NR']:\u000a            c50 = params[0]\u000a            n = params[1]\u000a            xx = c50/(1/yy-1)\u000a        return xx\u000a\u000aclass _baseFunctionFit:\u000a    """Not needed by most users except as a superclass for developping your own functions\u000a\u000a    You must overide the eval and inverse methods and a good idea to overide the _initialGuess\u000a    method aswell.\u000a    """\u000a\u000a    def __init__(self, xx, yy, sems=1.0, guess=None, display=1,\u000a                 expectedMin=0.5):\u000a        self.xx = numpy.asarray(xx)\u000a        self.yy = numpy.asarray(yy)\u000a        self.sems = numpy.asarray(sems)\u000a        self.expectedMin = expectedMin\u000a        self.display=display\u000a        # for holding error calculations:\u000a        self.ssq=0\u000a        self.rms=0\u000a        self.chi=0\u000a        #initialise parameters\u000a        if guess==None:\u000a            self.params = self._initialGuess()\u000a        else:\u000a            self.params = guess\u000a\u000a        #do the calculations:\u000a        self._doFit()\u000a\u000a    def _doFit(self):\u000a        #get some useful variables to help choose starting fit vals\u000a        self.params = optimize.fmin_powell(self._getErr, self.params, (self.xx,self.yy,self.sems),disp=self.display)\u000a#        self.params = optimize.fmin_bfgs(self._getErr, self.params, None, (self.xx,self.yy,self.sems),disp=self.display)\u000a        self.ssq = self._getErr(self.params, self.xx, self.yy, 1.0)\u000a        self.chi = self._getErr(self.params, self.xx, self.yy, self.sems)\u000a        self.rms = self.ssq/len(self.xx)\u000a\u000a    def _initialGuess(self):\u000a        xMin = min(self.xx); xMax = max(self.xx)\u000a        xRange=xMax-xMin; xMean= (xMax+xMin)/2.0\u000a        guess=[xMean, xRange/5.0]\u000a        return guess\u000a\u000a    def _getErr(self, params, xx,yy,sems):\u000a        mod = self.eval(xx, params)\u000a        err = sum((yy-mod)**2/sems)\u000a        return err\u000a\u000a    def eval(self, xx=None, params=None):\u000a        """Returns fitted yy for any given xx value(s).\u000a        Uses the original xx values (from which fit was calculated)\u000a        if none given.\u000a\u000a        If params is specified this will override the current model params."""\u000a        yy=xx\u000a        return yy\u000a\u000a    def inverse(self, yy, params=None):\u000a        """Returns fitted xx for any given yy value(s).\u000a\u000a        If params is specified this will override the current model params.\u000a        """\u000a        #define the inverse for your function here\u000a        xx=yy\u000a        return xx\u000a\u000a\u000aclass FitWeibull(_baseFunctionFit):\u000a    """Fit a Weibull function (either 2AFC or YN)\u000a    of the form::\u000a\u000a        y = chance + (1.0-chance)*(1-exp( -(xx/alpha)**(beta) ))\u000a\u000a    and with inverse::\u000a\u000a        x = alpha * (-log((1.0-y)/(1-chance)))**(1.0/beta)\u000a\u000a    After fitting the function you can evaluate an array of x-values\u000a    with ``fit.eval(x)``, retrieve the inverse of the function with\u000a    ``fit.inverse(y)`` or retrieve the parameters from ``fit.params``\u000a    (a list with ``[alpha, beta]``)"""\u000a    def eval(self, xx=None, params=None):\u000a        if params==None:  params=self.params #so the user can set params for this particular eval\u000a        alpha = params[0];\u000a        if alpha<=0: alpha=0.001\u000a        beta = params[1]\u000a        xx = numpy.asarray(xx)\u000a        yy =  self.expectedMin + (1.0-self.expectedMin)*(1-numpy.exp( -(xx/alpha)**(beta) ))\u000a        return yy\u000a    def inverse(self, yy, params=None):\u000a        if params==None: params=self.params #so the user can set params for this particular inv\u000a        alpha = params[0]\u000a        beta = params[1]\u000a        xx = alpha * (-numpy.log((1.0-yy)/(1-self.expectedMin))) **(1.0/beta)\u000a        return xx\u000aclass FitNakaRushton(_baseFunctionFit):\u000a    """Fit a Naka-Rushton function\u000a    of the form::\u000a\u000a        yy = rMin + (rMax-rMin) * xx**n/(xx**n+c50**n)\u000a\u000a    After fitting the function you can evaluate an array of x-values\u000a    with ``fit.eval(x)``, retrieve the inverse of the function with\u000a    ``fit.inverse(y)`` or retrieve the parameters from ``fit.params``\u000a    (a list with ``[rMin, rMax, c50, n]``)\u000a\u000a    Note that this differs from most of the other functions in\u000a    not using a value for the expected minimum. Rather, it fits this\u000a    as one of the parameters of the model."""\u000a    def __init__(self, xx, yy, sems=1.0, guess=None, display=1):\u000a        self.xx = numpy.asarray(xx)\u000a        self.yy = numpy.asarray(yy)\u000a        self.sems = numpy.asarray(sems)\u000a        self.display=display\u000a        # for holding error calculations:\u000a        self.ssq=0\u000a        self.rms=0\u000a        self.chi=0\u000a        #initialise parameters\u000a        if guess==None:\u000a            self.params = self._initialGuess()\u000a        else:\u000a            self.params = guess\u000a\u000a        #do the calculations:\u000a        self._doFit()\u000a    def _initialGuess(self):\u000a        xMin = min(self.xx); xMax = max(self.xx)\u000a        xRange=xMax-xMin; xMean= (xMax+xMin)/2.0\u000a        guess=[xMean, 2.0, min(self.yy), max(self.yy)-min(self.yy)]\u000a        return guess\u000a    def eval(self, xx=None, params=None):\u000a        if params==None:  params=self.params #so the user can set params for this particular eval\u000a        c50 = params[0]\u000a        n = params[1]\u000a        rMin = params[2]\u000a        rMax = params[3]\u000a        #all params should be >0\u000a        if c50<=0: c50=0.001\u000a        if n<=0: n=0.001\u000a        if rMax<=0: n=0.001\u000a        if rMin<=0: n=0.001\u000a\u000a        xx = numpy.asarray(xx)\u000a        yy = rMin + (rMax-rMin)*(xx**n/(xx**n+c50**n))\u000a        #yy = (xx**n/(xx**n+c50**n))\u000a        return yy\u000a\u000a    def inverse(self, yy, params=None):\u000a        if params==None: params=self.params #so the user can set params for this particular inv\u000a        yy=numpy.asarray(yy)\u000a        c50 = params[0]\u000a        n = params[1]\u000a        rMin = params[2]\u000a        rMax = params[3]\u000a\u000a        yScaled = (yy-rMin)/(rMax-rMin) #remove baseline and scale\u000a        xx = (yScaled*c50**n/(1-yScaled))**(1/n)\u000a        return xx\u000a\u000aclass FitLogistic(_baseFunctionFit):\u000a    """Fit a Logistic function (either 2AFC or YN)\u000a    of the form::\u000a\u000a        y = chance + (1-chance)/(1+exp((PSE-xx)*JND))\u000a\u000a    and with inverse::\u000a\u000a        x = PSE - log((1-chance)/(yy-chance) - 1)/JND\u000a\u000a    After fitting the function you can evaluate an array of x-values\u000a    with ``fit.eval(x)``, retrieve the inverse of the function with\u000a    ``fit.inverse(y)`` or retrieve the parameters from ``fit.params``\u000a    (a list with ``[PSE, JND]``)\u000a    """\u000a    def eval(self, xx=None, params=None):\u000a        if params==None:  params=self.params #so the user can set params for this particular eval\u000a        PSE = params[0]\u000a        JND = params[1]\u000a        chance = self.expectedMin\u000a        xx = numpy.asarray(xx)\u000a        yy = chance + (1-chance)/(1+numpy.exp((PSE-xx)*JND))\u000a        return yy\u000a    def inverse(self, yy, params=None):\u000a        if params==None: params=self.params #so the user can set params for this particular inv\u000a        PSE = params[0]\u000a        JND = params[1]\u000a        chance = self.expectedMin\u000a        yy = numpy.asarray(yy)\u000a        xx = PSE - numpy.log((1-chance)/(yy-chance) - 1)/JND\u000a        return xx\u000a\u000aclass FitCumNormal(_baseFunctionFit):\u000a    """Fit a Cumulative Normal function (aka error function or erf)\u000a    of the form::\u000a\u000a        y = chance + (1-chance)*(special.erf(xx*xScale - xShift)/2.0+0.5)\u000a\u000a    and with inverse::\u000a\u000a        x = (erfinv((yy-chance)/(1-chance)*2.0-1)+xShift)/xScale\u000a\u000a    After fitting the function you can evaluate an array of x-values\u000a    with fit.eval(x), retrieve the inverse of the function with\u000a    fit.inverse(y) or retrieve the parameters from fit.params\u000a    (a list with [centre, sd] for the Gaussian distribution forming the cumulative)\u000a\u000a    NB: Prior to version 1.74 the parameters had different meaning, relating\u000a    to xShift and slope of the function (similar to 1/sd). Although that is more in\u000a    with the parameters for the Weibull fit, for instance, it is less in keeping\u000a    with standard expectations of normal (Gaussian distributions) so in version\u000a    1.74.00 the parameters became the [centre,sd] of the normal distribution.\u000a\u000a    """\u000a    def eval(self, xx=None, params=None):\u000a        if params==None:  params=self.params #so the user can set params for this particular eval\u000a        xShift = params[0]\u000a        sd = params[1]\u000a        chance = self.expectedMin\u000a        #if xScale<=0: xScale=0.001\u000a        xx = numpy.asarray(xx)\u000a        yy = chance + (1-chance)*(special.erf((xx-xShift)/sd)/2.0+0.5)#NB numpy.special.erf() goes from -1:1\u000a        return yy\u000a    def inverse(self, yy, params=None):\u000a        if params==None: params=self.params #so the user can set params for this particular inv\u000a        xShift = params[0]\u000a        sd = params[1]\u000a        chance = self.expectedMin\u000a        #xx = (special.erfinv((yy-chance)/(1-chance)*2.0-1)+xShift)/xScale#NB numpy.special.erfinv() goes from -1:1\u000a        xx = xShift+sd*special.erfinv(( (yy-chance)/(1-chance) - 0.5 )*2)\u000a        return xx\u000a\u000a\u000a\u000a########################## End psychopy.data classes ##########################\u000a\u000adef bootStraps(dat, n=1):\u000a    """Create a list of n bootstrapped resamples of the data\u000a\u000a    SLOW IMPLEMENTATION (Python for-loop)\u000a\u000a    Usage:\u000a        ``out = bootStraps(dat, n=1)``\u000a\u000a    Where:\u000a        dat\u000a            an NxM or 1xN array (each row is a different condition, each column is a different trial)\u000a        n\u000a            number of bootstrapped resamples to create\u000a\u000a        out\u000a            - dim[0]=conditions\u000a            - dim[1]=trials\u000a            - dim[2]=resamples\u000a    """\u000a    dat = numpy.asarray(dat)\u000a    if len(dat.shape)==1: #have presumably been given a series of data for one stimulus\u000a        dat=numpy.array([dat])#adds a dimension (arraynow has shape (1,Ntrials))\u000a\u000a    nTrials = dat.shape[1]\u000a    #initialise a matrix to store output\u000a    resamples = numpy.zeros(dat.shape+(n,), dat.dtype)\u000a    for stimulusN in range(dat.shape[0]):\u000a        thisStim = dat[stimulusN,:]#fetch data for this stimulus\u000a        for sampleN in range(n):\u000a            indices = numpy.floor(nTrials*numpy.random.rand(nTrials)).astype('i')\u000a            resamples[stimulusN,:,sampleN] = numpy.take(thisStim, indices)\u000a    return resamples\u000a\u000adef functionFromStaircase(intensities, responses, bins = 10):\u000a    """Create a psychometric function by binning data from a staircase procedure\u000a\u000a    usage::\u000a\u000a        [intensity, meanCorrect, n] = functionFromStaircase(intensities, responses, bins)\u000a\u000a    where:\u000a            intensities\u000a                are a list of intensities to be binned\u000a\u000a            responses\u000a                are a list of 0,1 each corresponding to the equivalent intensity value\u000a\u000a            bins\u000a                can be an integer (giving that number of bins) or 'unique' (where each bin is made from ALL data for exactly one intensity value)\u000a\u000a            intensity\u000a                is the center of an intensity bin\u000a\u000a            meanCorrect\u000a                is mean % correct in that bin\u000a\u000a            n\u000a                is number of responses contributing to that mean\u000a    """\u000a    #convert to arrays\u000a    try:#concatenate if multidimensional\u000a        intensities = numpy.concatenate(intensities)\u000a        responses = numpy.concatenate(responses)\u000a    except:\u000a        intensities = numpy.array(intensities)\u000a        responses = numpy.array(responses)\u000a\u000a    #sort the responses\u000a    sort_ii = numpy.argsort(intensities)\u000a    sortedInten = numpy.take(intensities, sort_ii)\u000a    sortedResp = numpy.take(responses, sort_ii)\u000a\u000a    binnedResp=[]; binnedInten=[]; nPoints = []\u000a    if bins=='unique':\u000a        intensities = numpy.round(intensities, decimals=8)\u000a        uniqueIntens=numpy.unique(intensities)\u000a        for thisInten in uniqueIntens:\u000a            theseResps = responses[intensities==thisInten]\u000a            binnedInten.append(thisInten)\u000a            binnedResp.append(numpy.mean(theseResps))\u000a            nPoints.append(len(theseResps))\u000a    else:\u000a        pointsPerBin = len(intensities)/float(bins)\u000a        for binN in range(bins):\u000a            thisResp = sortedResp[int(round(binN*pointsPerBin)) : int(round((binN+1)*pointsPerBin))]\u000a            thisInten = sortedInten[int(round(binN*pointsPerBin)) : int(round((binN+1)*pointsPerBin))]\u000a\u000a            binnedResp.append( numpy.mean(thisResp))\u000a            binnedInten.append( numpy.mean(thisInten))\u000a            nPoints.append( len(thisInten) )\u000a\u000a    return binnedInten, binnedResp, nPoints\u000a\u000adef getDateStr(format="%Y_%b_%d_%H%M"):\u000a    """Uses ``time.strftime()``_ to generate a string of the form\u000a    2012_Apr_19_1531 for 19th April 3.31pm, 2012.\u000a    This is often useful appended to data filenames to provide unique names.\u000a    To include the year: getDateStr(format="%Y_%b_%d_%H%M") returns '2011_Mar_16_1307'\u000a    depending on locale, can have unicode chars in month names, so utf_8_decode them\u000a    For date in the format of the current localization, do:\u000a        data.getDateStr(format=locale.nl_langinfo(locale.D_T_FMT))\u000a    """\u000a    now = time.strftime(format, time.localtime())\u000a    try:\u000a        now_dec = codecs.utf_8_decode(now)[0]\u000a    except UnicodeDecodeError:\u000a        now_dec = time.strftime("%Y_%m_%d_%H%M", time.localtime())  # '2011_03_16_1307'\u000a\u000a    return now_dec\u000a\u000adef isValidVariableName(name):\u000a    """Checks whether a certain string could be used as a valid variable.\u000a\u000a    Usage::\u000a\u000a        OK, msg = isValidVariableName(name)\u000a\u000a    >>> isValidVariableName('name')\u000a    (True, '')\u000a    >>> isValidVariableName('0name')\u000a    (False, 'Variables cannot begin with numeric character')\u000a    >>> isValidVariableName('first second')\u000a    (False, 'Variables cannot contain punctuation or spaces')\u000a    >>> isValidVariableName('')\u000a    (False, "Variables cannot be missing, None, or ''")\u000a    >>> isValidVariableName(None)\u000a    (False, "Variables cannot be missing, None, or ''")\u000a    >>> isValidVariableName(23)\u000a    (False, "Variables must be string-like")\u000a    >>> isValidVariableName('a_b_c')\u000a    (True, '')\u000a    """\u000a    if not name:\u000a        return False, "Variables cannot be missing, None, or ''"\u000a    if not type(name) in [str, unicode, numpy.string_, numpy.unicode_]:\u000a        return False, "Variables must be string-like"\u000a    try:\u000a        name=str(name)#convert from unicode if possible\u000a    except:\u000a        if type(name) in [unicode, numpy.unicode_]:\u000a            raise AttributeError, "name %s (type %s) contains non-ASCII characters (e.g. accents)" % (name, type(name))\u000a        else:\u000a            raise AttributeError, "name %s (type %s) could not be converted to a string" % (name, type(name))\u000a\u000a    if name[0].isdigit():\u000a        return False, "Variables cannot begin with numeric character"\u000a    if _nonalphanumeric_re.search(name):\u000a        return False, "Variables cannot contain punctuation or spaces"\u000a    return True, ""\u000a\u000adef _getExcelCellName(col, row):\u000a    """Returns the excel cell name for a row and column (zero-indexed)\u000a\u000a    >>> _getExcelCellName(0,0)\u000a    'A1'\u000a    >>> _getExcelCellName(2,1)\u000a    'C2'\u000a    """\u000a    return "%s%i" %(get_column_letter(col+1), row+1)#BEWARE - openpyxl uses indexing at 1, to fit with Excel\u000a\u000a
p577
sS'thisTrial'
p578
(lp579
sS'_exp'
p580
I158727664
sg10
S'trials'
p581
sg6
S'C:\\Program Files (x86)\\PsychoPy2\\lib\\site-packages\\psychopy-1.74.01-py2.6.egg\\psychopy\\data.py'
p582
sS'thisRepN'
p583
I1
sS'nTotal'
p584
I78
sg17
g18
sS'data'
p585
g1
(cpsychopy.data
DataHandler
p586
c__builtin__
dict
p587
(dp588
S'ran'
p589
cnumpy.ma.core
_mareconstruct
p590
(cnumpy.ma.core
MaskedArray
p591
cnumpy
ndarray
p592
(I0
tp593
S'b'
tRp594
(I1
(I78
I1
tg49
(S'f4'
I0
I1
tRp595
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg15
g590
(g591
g592
g593
S'b'
tRp596
(I1
(I78
I1
tg595
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p597
g590
(g591
g592
g593
S'b'
tRp598
(I1
(I78
I1
tg595
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB\x00\x00\x90B\x00\x00\x92B\x00\x00\x94B\x00\x00\x96B\x00\x00\x98B\x00\x00\x9aB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg14
cnumpy.core.multiarray
_reconstruct
p599
(g592
(I0
tS'b'
tRp600
(I1
(I78
I1
tg49
(S'O4'
I0
I1
tRp601
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp602
NaNaNaS'3'
aS'3'
aS'2'
aS'1'
aS'1'
aS'2'
aS'3'
aS'2'
aS'2'
aS'2'
aNaS'3'
aS'3'
aS'1'
aS'2'
aS'1'
aS'3'
aS'3'
aS'2'
aS'2'
aS'1'
aS'3'
aS'3'
aS'2'
aNaS'2'
aS'3'
aS'3'
aS'2'
aS'3'
aS'1'
aS'2'
aS'3'
aNaS'2'
aS'2'
aS'2'
aS'3'
aS'3'
aS'1'
aS'2'
aS'1'
aS'1'
aS'4'
aS'4'
aS'4'
aS'4'
aS'3'
aS'3'
aS'2'
aS'2'
aS'2'
aS'3'
aS'3'
aS'2'
aS'1'
aS'1'
aS'2'
aS'3'
aS'2'
aS'1'
aS'2'
aS'3'
aS'3'
aS'3'
aS'1'
aS'2'
aS'1'
aS'3'
aS'3'
aS'2'
aS'2'
aS'1'
aS'1'
aS'3'
atbsg16
g590
(g591
g592
g593
S'b'
tRp603
(I1
(I78
I1
tg595
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8f\x84\xbd?\xce]\xb9>\xa7S\xcc?\xf6\x96\\?-\xdb\x84>|\x00\xa6?\x02\x9c\x90?;\xb9\xe7?+\x99\xb6?\xd4\xc5\xab?\x00\x00\x00\x00l\\\x8a>g$v>\xab%>?=\xd5\xc4>\x84T\x8a>\xac\xc1\xbb?\x8dT\x8d?\x15\x8e\xaa>N\xa3\xb2>m\xff\x9f?f\xca\x8c>\xa5\x90\x8d>\xa53\x9d?\x00\x00\x00\x00\xc9\x1b\xda>\x8a\x12+?\xdf\xe2\xc7?$\x93@?<\xd0|?\xbd1o>\xddI[?\xae\xb1k>\x00\x00\x00\x00\xef\xf7G?\x80Ca>j\x12>?\x87]\xb3>\xf3\x1a\x0f?\xb9\xa6??\xee)K?\xc6L\xc1=\x14\xc7\x0c?\xd80\x89?\xb9\x90k>N`G>1PM=\xb9N\xb1>\xbddU>\x03\xe3\xf9>\x1d\xa1\x1e>\x08.\xa1=\xad\x14\xbc?\x999e>G\x1b\x7f>8ho>\xd1$\xbc=\xdd\xe4\xc1>udt>\xa8\x82\x99?\xbc/\xb9>\x9b"I>\xaafI?\xae\xd0\x10?T\xe0U>V\x9eM?\xcb\x87\x1b>\xf2\x85A?\x12\xb1f>a\x90V=i>\x8b>@0u>>Qj>\x08\x87\x07?\x19J\x8b>'
S'\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp604
(dp605
S'isNumeric'
p606
(dp607
g589
I01
sg15
I01
sg597
I01
sg16
I01
sg14
I00
ssg581
g574
sS'dataTypes'
p608
(lp609
g589
ag597
ag14
ag15
ag16
asS'dataShape'
p610
(lp611
I78
aI1
asbsS'thisN'
p612
I78
sS'sequenceIndices'
p613
g599
(g592
(I0
tS'b'
tRp614
(I1
(I78
I1
tg50
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00'
tbsS'finished'
p615
I01
sS'nReps'
p616
I1
sS'nRemaining'
p617
I-1
sS'trialList'
p618
(lp619
g1
(cpsychopy.data
TrialType
p620
g587
(dp621
g33
I96
sg34
g55
sg35
g58
sg36
I1
sg42
g53
sg38
I66
sg39
F2.688027210884353
sg40
g57
sg41
I25
sg37
F0.97211157047895325
sg43
I2
stRp622
ag1
(g620
g587
(dp623
g33
I80
sg34
g64
sg35
g58
sg36
I2
sg42
g53
sg38
I50
sg39
F3.5404761904761903
sg40
g66
sg41
I9
sg37
F-1.4805664680963626
sg43
I3
stRp624
ag1
(g620
g587
(dp625
g33
I97
sg34
g72
sg35
g58
sg36
I3
sg42
g53
sg38
I67
sg39
F3.0989115646258503
sg40
g74
sg41
I26
sg37
F0.98948011330479291
sg43
I2
stRp626
ag1
(g620
g587
(dp627
g33
I84
sg34
g76
sg35
g58
sg36
I4
sg42
g53
sg38
I54
sg39
F3.1113832199546403
sg40
g82
sg41
I13
sg37
F-0.41232228679959398
sg43
I3
stRp628
ag1
(g620
g587
(dp629
g33
I73
sg34
g84
sg35
g58
sg36
I5
sg42
g53
sg38
I43
sg39
F3.75081632653061
sg40
g90
sg41
I3
sg37
F-0.53706073129766818
sg43
I1
stRp630
ag1
(g620
g587
(dp631
g33
I71
sg34
g92
sg35
g58
sg36
I6
sg42
g53
sg38
I41
sg39
F3.13696145124716
sg40
g98
sg41
I1
sg37
F-1.1424907215263371
sg43
I1
stRp632
ag1
(g620
g587
(dp633
g33
I85
sg34
g100
sg35
g58
sg36
I7
sg42
g53
sg38
I55
sg39
F3.16766439909297
sg40
g106
sg41
I14
sg37
F0.15674237052672263
sg43
I3
stRp634
ag1
(g620
g587
(dp635
g33
I78
sg34
g108
sg35
g58
sg36
I8
sg42
g53
sg38
I48
sg39
F3.3681859410430799
sg40
g114
sg41
I8
sg37
F1.4242230970513805
sg43
I1
stRp636
ag1
(g620
g587
(dp637
g33
I92
sg34
g116
sg35
g58
sg36
I9
sg42
g53
sg38
I62
sg39
F3.3168480725623501
sg40
g122
sg41
I21
sg37
F-0.63412378462273378
sg43
I2
stRp638
ag1
(g620
g587
(dp639
g33
I72
sg34
g124
sg35
g58
sg36
I10
sg42
g53
sg38
I42
sg39
F3.8270294784580399
sg40
g130
sg41
I2
sg37
F-1.1293393049458027
sg43
I1
stRp640
ag1
(g620
g587
(dp641
g33
I74
sg34
g132
sg35
g58
sg36
I11
sg42
g53
sg38
I44
sg39
F3.2894784580498797
sg40
g138
sg41
I4
sg37
F-0.3072020091293417
sg43
I1
stRp642
ag1
(g620
g587
(dp643
g33
I83
sg34
g140
sg35
g58
sg36
I12
sg42
g53
sg38
I53
sg39
F3.5562358276643899
sg40
g146
sg41
I12
sg37
F-0.62197768686718324
sg43
I3
stRp644
ag1
(g620
g587
(dp645
g33
I93
sg34
g148
sg35
g58
sg36
I13
sg42
g53
sg38
I63
sg39
F3.0609977324263
sg40
g154
sg41
I22
sg37
F0.16624841156760786
sg43
I2
stRp646
ag1
(g620
g587
(dp647
g33
I94
sg34
g160
sg35
g58
sg36
I14
sg42
g53
sg38
I64
sg39
F3.6325170068027202
sg40
g162
sg41
I23
sg37
F0.46505470843950819
sg43
I2
stRp648
ag1
(g620
g587
(dp649
g33
I87
sg34
g164
sg35
g58
sg36
I15
sg42
g53
sg38
I57
sg39
F3.9615873015872998
sg40
g170
sg41
I16
sg37
F0.80567575168831174
sg43
I3
stRp650
ag1
(g620
g587
(dp651
g33
I89
sg34
g172
sg35
g58
sg36
I16
sg42
g53
sg38
I59
sg39
F3.9851927437641699
sg40
g178
sg41
I18
sg37
F1.4046911804528555
sg43
I3
stRp652
ag1
(g620
g587
(dp653
g33
I75
sg34
g180
sg35
g58
sg36
I17
sg42
g53
sg38
I45
sg39
F3.18668934240362
sg40
g186
sg41
I5
sg37
F0.063624465804048597
sg43
I1
stRp654
ag1
(g620
g587
(dp655
g33
I95
sg34
g188
sg35
g58
sg36
I18
sg42
g53
sg38
I65
sg39
F3.9427210884353698
sg40
g194
sg41
I24
sg37
F0.78164074653547022
sg43
I2
stRp656
ag1
(g620
g587
(dp657
g33
I76
sg34
g196
sg35
g58
sg36
I19
sg42
g53
sg38
I46
sg39
F3.35551020408163
sg40
g202
sg41
I6
sg37
F0.23169249593766542
sg43
I1
stRp658
ag1
(g620
g587
(dp659
g33
I82
sg34
g204
sg35
g58
sg36
I20
sg42
g53
sg38
I52
sg39
F2.8854421768707481
sg40
g210
sg41
I11
sg37
F-0.7317971821406829
sg43
I3
stRp660
ag1
(g620
g587
(dp661
g33
I88
sg34
g212
sg35
g58
sg36
I21
sg42
g53
sg38
I58
sg39
F3.54068027210884
sg40
g218
sg41
I17
sg37
F1.2549373232617196
sg43
I3
stRp662
ag1
(g620
g587
(dp663
g33
I91
sg34
g220
sg35
g58
sg36
I22
sg42
g53
sg38
I61
sg39
F3.7509750566893398
sg40
g226
sg41
I20
sg37
F-1.1913061482898895
sg43
I2
stRp664
ag1
(g620
g587
(dp665
g33
I90
sg34
g228
sg35
g58
sg36
I23
sg42
g53
sg38
I60
sg39
F3.30308390022675
sg40
g234
sg41
I19
sg37
F-1.5491056174137092
sg43
I2
stRp666
ag1
(g620
g587
(dp667
g33
I77
sg34
g236
sg35
g58
sg36
I24
sg42
g53
sg38
I47
sg39
F3.0733333333333297
sg40
g242
sg41
I7
sg37
F1.3965527081060551
sg43
I1
stRp668
ag1
(g620
g587
(dp669
g33
I81
sg34
g244
sg35
g58
sg36
I25
sg42
g53
sg38
I51
sg39
F3.6721768707482898
sg40
g250
sg41
I10
sg37
F-1.0313048965229548
sg43
I3
stRp670
ag1
(g620
g587
(dp671
g33
I86
sg34
g252
sg35
g58
sg36
I26
sg42
g53
sg38
I56
sg39
F3.4781405895691599
sg40
g258
sg41
I15
sg37
F0.65592189449717464
sg43
I3
stRp672
ag1
(g620
g587
(dp673
g33
I96
sg34
g55
sg35
g58
sg36
I27
sg42
g53
sg38
I66
sg39
F2.688027210884353
sg40
g57
sg41
I25
sg37
F0.97211157047895325
sg43
I2
stRp674
ag1
(g620
g587
(dp675
g33
I80
sg34
g64
sg35
g58
sg36
I28
sg42
g53
sg38
I50
sg39
F3.5404761904761903
sg40
g66
sg41
I9
sg37
F-1.4805664680963626
sg43
I3
stRp676
ag1
(g620
g587
(dp677
g33
I97
sg34
g72
sg35
g58
sg36
I29
sg42
g53
sg38
I67
sg39
F3.0989115646258503
sg40
g74
sg41
I26
sg37
F0.98948011330479291
sg43
I2
stRp678
ag1
(g620
g587
(dp679
g33
I84
sg34
g76
sg35
g58
sg36
I30
sg42
g53
sg38
I54
sg39
F3.1113832199546403
sg40
g82
sg41
I13
sg37
F-0.41232228679959398
sg43
I3
stRp680
ag1
(g620
g587
(dp681
g33
I73
sg34
g84
sg35
g58
sg36
I31
sg42
g53
sg38
I43
sg39
F3.75081632653061
sg40
g90
sg41
I3
sg37
F-0.53706073129766818
sg43
I1
stRp682
ag1
(g620
g587
(dp683
g33
I71
sg34
g92
sg35
g58
sg36
I32
sg42
g53
sg38
I41
sg39
F3.13696145124716
sg40
g98
sg41
I1
sg37
F-1.1424907215263371
sg43
I1
stRp684
ag1
(g620
g587
(dp685
g33
I85
sg34
g100
sg35
g58
sg36
I33
sg42
g53
sg38
I55
sg39
F3.16766439909297
sg40
g106
sg41
I14
sg37
F0.15674237052672263
sg43
I3
stRp686
ag1
(g620
g587
(dp687
g33
I78
sg34
g108
sg35
g58
sg36
I34
sg42
g53
sg38
I48
sg39
F3.3681859410430799
sg40
g114
sg41
I8
sg37
F1.4242230970513805
sg43
I1
stRp688
ag1
(g620
g587
(dp689
g33
I92
sg34
g116
sg35
g58
sg36
I35
sg42
g53
sg38
I62
sg39
F3.3168480725623501
sg40
g122
sg41
I21
sg37
F-0.63412378462273378
sg43
I2
stRp690
ag1
(g620
g587
(dp691
g33
I72
sg34
g124
sg35
g58
sg36
I36
sg42
g53
sg38
I42
sg39
F3.8270294784580399
sg40
g130
sg41
I2
sg37
F-1.1293393049458027
sg43
I1
stRp692
ag1
(g620
g587
(dp693
g33
I74
sg34
g132
sg35
g58
sg36
I37
sg42
g53
sg38
I44
sg39
F3.2894784580498797
sg40
g138
sg41
I4
sg37
F-0.3072020091293417
sg43
I1
stRp694
ag1
(g620
g587
(dp695
g33
I83
sg34
g140
sg35
g58
sg36
I38
sg42
g53
sg38
I53
sg39
F3.5562358276643899
sg40
g146
sg41
I12
sg37
F-0.62197768686718324
sg43
I3
stRp696
ag1
(g620
g587
(dp697
g33
I93
sg34
g148
sg35
g58
sg36
I39
sg42
g53
sg38
I63
sg39
F3.0609977324263
sg40
g154
sg41
I22
sg37
F0.16624841156760786
sg43
I2
stRp698
ag1
(g620
g587
(dp699
g33
I94
sg34
g160
sg35
g58
sg36
I40
sg42
g53
sg38
I64
sg39
F3.6325170068027202
sg40
g162
sg41
I23
sg37
F0.46505470843950819
sg43
I2
stRp700
ag1
(g620
g587
(dp701
g33
I87
sg34
g164
sg35
g58
sg36
I41
sg42
g53
sg38
I57
sg39
F3.9615873015872998
sg40
g170
sg41
I16
sg37
F0.80567575168831174
sg43
I3
stRp702
ag1
(g620
g587
(dp703
g33
I89
sg34
g172
sg35
g58
sg36
I42
sg42
g53
sg38
I59
sg39
F3.9851927437641699
sg40
g178
sg41
I18
sg37
F1.4046911804528555
sg43
I3
stRp704
ag1
(g620
g587
(dp705
g33
I75
sg34
g180
sg35
g58
sg36
I43
sg42
g53
sg38
I45
sg39
F3.18668934240362
sg40
g186
sg41
I5
sg37
F0.063624465804048597
sg43
I1
stRp706
ag1
(g620
g587
(dp707
g33
I95
sg34
g188
sg35
g58
sg36
I44
sg42
g53
sg38
I65
sg39
F3.9427210884353698
sg40
g194
sg41
I24
sg37
F0.78164074653547022
sg43
I2
stRp708
ag1
(g620
g587
(dp709
g33
I76
sg34
g196
sg35
g58
sg36
I45
sg42
g53
sg38
I46
sg39
F3.35551020408163
sg40
g202
sg41
I6
sg37
F0.23169249593766542
sg43
I1
stRp710
ag1
(g620
g587
(dp711
g33
I82
sg34
g204
sg35
g58
sg36
I46
sg42
g53
sg38
I52
sg39
F2.8854421768707481
sg40
g210
sg41
I11
sg37
F-0.7317971821406829
sg43
I3
stRp712
ag1
(g620
g587
(dp713
g33
I88
sg34
g212
sg35
g58
sg36
I47
sg42
g53
sg38
I58
sg39
F3.54068027210884
sg40
g218
sg41
I17
sg37
F1.2549373232617196
sg43
I3
stRp714
ag1
(g620
g587
(dp715
g33
I91
sg34
g220
sg35
g58
sg36
I48
sg42
g53
sg38
I61
sg39
F3.7509750566893398
sg40
g226
sg41
I20
sg37
F-1.1913061482898895
sg43
I2
stRp716
ag1
(g620
g587
(dp717
g33
I90
sg34
g228
sg35
g58
sg36
I49
sg42
g53
sg38
I60
sg39
F3.30308390022675
sg40
g234
sg41
I19
sg37
F-1.5491056174137092
sg43
I2
stRp718
ag1
(g620
g587
(dp719
g33
I77
sg34
g236
sg35
g58
sg36
I50
sg42
g53
sg38
I47
sg39
F3.0733333333333297
sg40
g242
sg41
I7
sg37
F1.3965527081060551
sg43
I1
stRp720
ag1
(g620
g587
(dp721
g33
I81
sg34
g244
sg35
g58
sg36
I51
sg42
g53
sg38
I51
sg39
F3.6721768707482898
sg40
g250
sg41
I10
sg37
F-1.0313048965229548
sg43
I3
stRp722
ag1
(g620
g587
(dp723
g33
I86
sg34
g252
sg35
g58
sg36
I52
sg42
g53
sg38
I56
sg39
F3.4781405895691599
sg40
g258
sg41
I15
sg37
F0.65592189449717464
sg43
I3
stRp724
ag1
(g620
g587
(dp725
g33
I96
sg34
g55
sg35
g58
sg36
I53
sg42
g53
sg38
I66
sg39
F2.688027210884353
sg40
g57
sg41
I25
sg37
F0.97211157047895325
sg43
I2
stRp726
ag1
(g620
g587
(dp727
g33
I80
sg34
g64
sg35
g58
sg36
I54
sg42
g53
sg38
I50
sg39
F3.5404761904761903
sg40
g66
sg41
I9
sg37
F-1.4805664680963626
sg43
I3
stRp728
ag1
(g620
g587
(dp729
g33
I97
sg34
g72
sg35
g58
sg36
I55
sg42
g53
sg38
I67
sg39
F3.0989115646258503
sg40
g74
sg41
I26
sg37
F0.98948011330479291
sg43
I2
stRp730
ag1
(g620
g587
(dp731
g33
I84
sg34
g76
sg35
g58
sg36
I56
sg42
g53
sg38
I54
sg39
F3.1113832199546403
sg40
g82
sg41
I13
sg37
F-0.41232228679959398
sg43
I3
stRp732
ag1
(g620
g587
(dp733
g33
I73
sg34
g84
sg35
g58
sg36
I57
sg42
g53
sg38
I43
sg39
F3.75081632653061
sg40
g90
sg41
I3
sg37
F-0.53706073129766818
sg43
I1
stRp734
ag1
(g620
g587
(dp735
g33
I71
sg34
g92
sg35
g58
sg36
I58
sg42
g53
sg38
I41
sg39
F3.13696145124716
sg40
g98
sg41
I1
sg37
F-1.1424907215263371
sg43
I1
stRp736
ag1
(g620
g587
(dp737
g33
I85
sg34
g100
sg35
g58
sg36
I59
sg42
g53
sg38
I55
sg39
F3.16766439909297
sg40
g106
sg41
I14
sg37
F0.15674237052672263
sg43
I3
stRp738
ag1
(g620
g587
(dp739
g33
I78
sg34
g108
sg35
g58
sg36
I60
sg42
g53
sg38
I48
sg39
F3.3681859410430799
sg40
g114
sg41
I8
sg37
F1.4242230970513805
sg43
I1
stRp740
ag1
(g620
g587
(dp741
g33
I92
sg34
g116
sg35
g58
sg36
I61
sg42
g53
sg38
I62
sg39
F3.3168480725623501
sg40
g122
sg41
I21
sg37
F-0.63412378462273378
sg43
I2
stRp742
ag1
(g620
g587
(dp743
g33
I72
sg34
g124
sg35
g58
sg36
I62
sg42
g53
sg38
I42
sg39
F3.8270294784580399
sg40
g130
sg41
I2
sg37
F-1.1293393049458027
sg43
I1
stRp744
ag1
(g620
g587
(dp745
g33
I74
sg34
g132
sg35
g58
sg36
I63
sg42
g53
sg38
I44
sg39
F3.2894784580498797
sg40
g138
sg41
I4
sg37
F-0.3072020091293417
sg43
I1
stRp746
ag1
(g620
g587
(dp747
g33
I83
sg34
g140
sg35
g58
sg36
I64
sg42
g53
sg38
I53
sg39
F3.5562358276643899
sg40
g146
sg41
I12
sg37
F-0.62197768686718324
sg43
I3
stRp748
ag1
(g620
g587
(dp749
g33
I93
sg34
g148
sg35
g58
sg36
I65
sg42
g53
sg38
I63
sg39
F3.0609977324263
sg40
g154
sg41
I22
sg37
F0.16624841156760786
sg43
I2
stRp750
ag1
(g620
g587
(dp751
g33
I94
sg34
g160
sg35
g58
sg36
I66
sg42
g53
sg38
I64
sg39
F3.6325170068027202
sg40
g162
sg41
I23
sg37
F0.46505470843950819
sg43
I2
stRp752
ag1
(g620
g587
(dp753
g33
I87
sg34
g164
sg35
g58
sg36
I67
sg42
g53
sg38
I57
sg39
F3.9615873015872998
sg40
g170
sg41
I16
sg37
F0.80567575168831174
sg43
I3
stRp754
ag1
(g620
g587
(dp755
g33
I89
sg34
g172
sg35
g58
sg36
I68
sg42
g53
sg38
I59
sg39
F3.9851927437641699
sg40
g178
sg41
I18
sg37
F1.4046911804528555
sg43
I3
stRp756
ag1
(g620
g587
(dp757
g33
I75
sg34
g180
sg35
g58
sg36
I69
sg42
g53
sg38
I45
sg39
F3.18668934240362
sg40
g186
sg41
I5
sg37
F0.063624465804048597
sg43
I1
stRp758
ag1
(g620
g587
(dp759
g33
I95
sg34
g188
sg35
g58
sg36
I70
sg42
g53
sg38
I65
sg39
F3.9427210884353698
sg40
g194
sg41
I24
sg37
F0.78164074653547022
sg43
I2
stRp760
ag1
(g620
g587
(dp761
g33
I76
sg34
g196
sg35
g58
sg36
I71
sg42
g53
sg38
I46
sg39
F3.35551020408163
sg40
g202
sg41
I6
sg37
F0.23169249593766542
sg43
I1
stRp762
ag1
(g620
g587
(dp763
g33
I82
sg34
g204
sg35
g58
sg36
I72
sg42
g53
sg38
I52
sg39
F2.8854421768707481
sg40
g210
sg41
I11
sg37
F-0.7317971821406829
sg43
I3
stRp764
ag1
(g620
g587
(dp765
g33
I88
sg34
g212
sg35
g58
sg36
I73
sg42
g53
sg38
I58
sg39
F3.54068027210884
sg40
g218
sg41
I17
sg37
F1.2549373232617196
sg43
I3
stRp766
ag1
(g620
g587
(dp767
g33
I91
sg34
g220
sg35
g58
sg36
I74
sg42
g53
sg38
I61
sg39
F3.7509750566893398
sg40
g226
sg41
I20
sg37
F-1.1913061482898895
sg43
I2
stRp768
ag1
(g620
g587
(dp769
g33
I90
sg34
g228
sg35
g58
sg36
I75
sg42
g53
sg38
I60
sg39
F3.30308390022675
sg40
g234
sg41
I19
sg37
F-1.5491056174137092
sg43
I2
stRp770
ag1
(g620
g587
(dp771
g33
I77
sg34
g236
sg35
g58
sg36
I76
sg42
g53
sg38
I47
sg39
F3.0733333333333297
sg40
g242
sg41
I7
sg37
F1.3965527081060551
sg43
I1
stRp772
ag1
(g620
g587
(dp773
g33
I81
sg34
g244
sg35
g58
sg36
I77
sg42
g53
sg38
I51
sg39
F3.6721768707482898
sg40
g250
sg41
I10
sg37
F-1.0313048965229548
sg43
I3
stRp774
ag1
(g620
g587
(dp775
g33
I86
sg34
g252
sg35
g58
sg36
I78
sg42
g53
sg38
I56
sg39
F3.4781405895691599
sg40
g258
sg41
I15
sg37
F0.65592189449717464
sg43
I3
stRp776
asS'seed'
p777
NsS'thisIndex'
p778
g567
sS'thisTrialN'
p779
I0
sS'method'
p780
S'sequential'
p781
sS'_warnUseOfNext'
p782
I01
sbasS'savePickle'
p783
I01
sb.